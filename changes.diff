diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..43ae0e2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+__pycache__/
+*.py[cod]
diff --git a/.idea/NightCityBot.iml b/.idea/NightCityBot.iml
index 8388dbc..fe1e139 100644
--- a/.idea/NightCityBot.iml
+++ b/.idea/NightCityBot.iml
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.9" jdkType="Python SDK" />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.venv" />
+    </content>
+    <orderEntry type="jdk" jdkName="Python 3.12 (NightCityBot)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
index 812ab5a..dcbbba5 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -3,5 +3,5 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.9" />
   </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (NightCityBot)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
index d843f34..35eb1dd 100644
--- a/.idea/vcs.xml
+++ b/.idea/vcs.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="VcsDirectoryMappings" defaultProject="true" />
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
 </project>
\ No newline at end of file
diff --git a/NightCityBot/bot.py b/NightCityBot/bot.py
index 74f7d60..420ef50 100644
--- a/NightCityBot/bot.py
+++ b/NightCityBot/bot.py
@@ -1,5 +1,13 @@
 import discord
 from discord.ext import commands
+import os
+import sys
+
+# Ensure the package root is on the path when executed as a script
+package_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+if package_root not in sys.path:
+    sys.path.insert(0, package_root)
+
 import config
 from NightCityBot.utils.permissions import is_fixer
 from NightCityBot.cogs.dm_handling import DMHandler
@@ -8,6 +16,9 @@ from NightCityBot.cogs.rp_manager import RPManager
 from NightCityBot.cogs.roll_system import RollSystem
 from NightCityBot.cogs.admin import Admin
 from NightCityBot.cogs.test_suite import TestSuite
+from NightCityBot.cogs.cyberware import CyberwareManager
+from NightCityBot.cogs.loa import LOA
+from NightCityBot.cogs.system_control import SystemControl
 from flask import Flask
 from threading import Thread
 
@@ -29,19 +40,28 @@ class NightCityBot(commands.Bot):
     async def setup_hook(self):
         # Load all cogs
         await self.add_cog(DMHandler(self))
+        await self.add_cog(SystemControl(self))
         await self.add_cog(Economy(self))
         await self.add_cog(RPManager(self))
         await self.add_cog(RollSystem(self))
+        await self.add_cog(CyberwareManager(self))
+        await self.add_cog(LOA(self))
         await self.add_cog(Admin(self))
         await self.add_cog(TestSuite(self))
 
     async def on_message(self, message: discord.Message):
+        if message.author == self.user or message.author.bot:
+            return
         dm_handler = self.get_cog('DMHandler')
         if dm_handler and isinstance(message.channel, discord.Thread):
             if message.channel.id in getattr(dm_handler, 'dm_threads', {}).values():
                 # Let DMHandler process without invoking commands to avoid duplicates
                 return
 
+        if isinstance(message.channel, discord.TextChannel) and message.channel.name.startswith("text-rp-"):
+            # RPManager handles command invocation for text RP channels
+            return
+
         await self.process_commands(message)
 
     async def on_ready(self):
diff --git a/NightCityBot/cogs/admin.py b/NightCityBot/cogs/admin.py
index c166d74..3ce33ae 100644
--- a/NightCityBot/cogs/admin.py
+++ b/NightCityBot/cogs/admin.py
@@ -3,6 +3,7 @@ from discord.ext import commands
 from typing import Optional
 import config
 from NightCityBot.utils.permissions import is_fixer
+from NightCityBot.utils import constants
 
 
 class Admin(commands.Cog):
@@ -49,12 +50,16 @@ class Admin(commands.Cog):
                 setattr(fake_ctx, "skip_dm_log", True)
 
                 await self.bot.invoke(fake_ctx)
-                await ctx.send(f"✅ Executed `{command_text}` in {dest_channel.mention}.")
+                await self.log_audit(ctx.author, f"✅ Executed `{command_text}` in {dest_channel.mention}.")
             else:
                 await dest_channel.send(content=message, files=files)
-                await ctx.send(f"✅ Posted anonymously to {dest_channel.mention}.")
+                await self.log_audit(ctx.author, f"✅ Posted anonymously to {dest_channel.mention}.")
         else:
             await ctx.send("❌ Provide a message or attachment.")
+        try:
+            await ctx.message.delete()
+        except Exception:
+            pass
 
     @commands.command(name="help")
     async def block_help(self, ctx):
@@ -85,14 +90,43 @@ class Admin(commands.Cog):
             value=(
                 "Everyone pays a **$500/month** baseline fee for survival (food, water, etc).\n"
                 "Even if you don't have a house or business — you're still eating Prepack.\n\n"
-                "`!open_shop`\n"
-                "→ Shop owners log up to 4 openings/month (Sundays only).\n"
-                "→ Increases passive income if you're active."
+                "`!open_shop` — Sundays only\n"
+                "→ Log up to 4 openings per month. Each opening grants an immediate cash payout based on your business tier.\n"
+                "→ Requires a Business role.\n"
+                "`!attend` — Sundays only\n"
+                "→ Verified players earn $250 every week they attend.\n"
+                "`!due` — Estimate what you'll owe on the 1st."
             ),
             inline=False
         )
 
-        # Add other help fields...
+        embed.add_field(
+            name="🦾 Cyberware Maintenance",
+            value=(
+                "Players with cyberware roles receive a **Checkup** role every Monday. Remove it after your in-game check-up.\n"
+                "If you still have the role the following week, immunosuppressant costs double each week. They start at about $15 for Medium, $40 for High, and $80 for Extreme.\n"
+                "Costs cap after roughly 8 weeks at $2,000 / $5,000 / $10,000 respectively."
+            ),
+            inline=False
+        )
+
+        embed.add_field(
+            name="🏖️ Leave of Absence",
+            value=(
+                "Use `!start_loa` to pause housing rent, baseline fees, Trauma Team, and cyberware costs.\n"
+                "`!end_loa` when you return. Business rent still applies."
+            ),
+            inline=False
+        )
+
+        embed.add_field(
+            name="🦾 Ripperdoc",
+            value=(
+                "`!checkup @user` — Remove the weekly cyberware checkup role.\n"
+                "`!weeks_without_checkup @user` — Show checkup streak."
+            ),
+            inline=False,
+        )
 
         embed.set_footer(text="Use !roll, pay your rent, stay alive.")
         await ctx.send(embed=embed)
@@ -100,22 +134,89 @@ class Admin(commands.Cog):
     @commands.command(name="helpfixer")
     async def helpfixer(self, ctx):
         """Display help for fixers."""
-        embed = discord.Embed(
+        def embed_len(e: discord.Embed) -> int:
+            total = len(e.title or "") + len(e.description or "")
+            if e.footer and e.footer.text:
+                total += len(e.footer.text)
+            for f in e.fields:
+                total += len(f.name) + len(str(f.value))
+            return total
+
+        fields = [
+            (
+                "✉️ Messaging Tools",
+                "`!dm @user <text>` — Send an anonymous DM to a user. Use `!roll` inside to relay a roll.\n"
+                "`!post <channel|thread> <message>` — Post or run a command in another location.",
+            ),
+            (
+                "📑 RP Management",
+                "`!start_rp @users` — Create a private RP channel for the listed users.\n"
+                "`!end_rp` — Archive and delete the current RP session.",
+            ),
+            (
+                "💵 Rent Commands",
+                "`!collect_rent [@user]` — Run monthly rent collection globally or for one user. Use `-v` for verbose output.\n"
+                "`!collect_housing @user` — Charge housing rent immediately.\n"
+                "`!collect_business @user` — Charge business rent immediately.\n"
+                "`!collect_trauma @user` — Process Trauma Team subscription.\n"
+                "`!simulate_rent` — Preview rent collection without changes. Use `-v` for verbose output.\n"
+                "`!simulate_cyberware [@user] [weeks]` — Preview cyberware costs.",
+            ),
+            (
+                "⚙️ System Control",
+                "`!enable_system <name>` — Turn a system on.\n"
+                "`!disable_system <name>` — Turn a system off.\n"
+                "`!system_status` — Show current system states.",
+            ),
+            (
+                "🦾 Ripperdoc",
+                "`!checkup @user` — Remove the weekly cyberware checkup role.",
+            ),
+            (
+                "🧪 Testing",
+                "`!test_bot [tests]` — Run self-tests (bot owner only).",
+            ),
+        ]
+
+        embeds = []
+        current = discord.Embed(
             title="🛠️ NCRP Bot — Fixer & Admin Help",
             description="Advanced commands for messaging, RP management, rent, and testing.",
-            color=discord.Color.purple()
+            color=discord.Color.purple(),
         )
-
-        # Add fixer help fields...
-
-        embed.set_footer(text="Fixer tools by MedusaCascade | v1.2")
-        await ctx.send(embed=embed)
+        for name, value in fields:
+            if embed_len(current) + len(name) + len(value) > 5800:
+                current.set_footer(text="Fixer tools by MedusaCascade | v1.2")
+                embeds.append(current)
+                current = discord.Embed(
+                    title="🛠️ NCRP Bot — Fixer & Admin Help (cont.)",
+                    color=discord.Color.purple(),
+                )
+            current.add_field(name=name, value=value, inline=False)
+
+        current.set_footer(text="Fixer tools by MedusaCascade | v1.2")
+        embeds.append(current)
+
+        for e in embeds:
+            await ctx.send(embed=e)
 
     @commands.Cog.listener()
     async def on_command_error(self, ctx, error):
         """Global error handler for commands."""
+        # Ignore errors triggered by other bots to avoid feedback loops
+        if getattr(ctx.author, "bot", False):
+            return
         if isinstance(error, commands.CommandNotFound):
-            # Ignore unknown commands so other bots using `!` don't spam the audit log
+            # Ignore specific economy bot commands entirely
+            cmd = ctx.message.content.lstrip(self.bot.command_prefix).split()[0].lower()
+            if cmd in constants.UNBELIEVABOAT_COMMANDS:
+                return
+            # Otherwise show a basic notice but do not audit
+            print(
+                f"[DEBUG] Unknown command from {ctx.author}"
+                f" in {getattr(ctx.channel, 'name', ctx.channel.id)}"
+                f" ({ctx.channel.id}) → {ctx.message.content!r}"
+            )
             await ctx.send("❌ Unknown command.")
             return
         elif isinstance(error, commands.CheckFailure):
diff --git a/NightCityBot/cogs/cyberware.py b/NightCityBot/cogs/cyberware.py
new file mode 100644
index 0000000..19b5c02
--- /dev/null
+++ b/NightCityBot/cogs/cyberware.py
@@ -0,0 +1,268 @@
+import discord
+from discord.ext import commands, tasks
+from datetime import datetime, time
+from zoneinfo import ZoneInfo
+from typing import Dict, Optional, List
+from pathlib import Path
+
+import config
+from NightCityBot.utils.helpers import load_json_file, save_json_file
+from NightCityBot.services.unbelievaboat import UnbelievaBoatAPI
+from NightCityBot.utils.permissions import is_ripperdoc, is_fixer
+
+MAX_COST = {
+    "medium": 2000,
+    "high": 5000,
+    "extreme": 10000,
+}
+BASE_FACTOR = {k: v / 128 for k, v in MAX_COST.items()}
+
+
+class CyberwareManager(commands.Cog):
+    """Handle weekly cyberware check-ups and medication costs."""
+
+    def __init__(self, bot: commands.Bot):
+        self.bot = bot
+        self.unbelievaboat = UnbelievaBoatAPI(config.UNBELIEVABOAT_API_TOKEN)
+        self.data: Dict[str, int] = {}
+        self.bot.loop.create_task(self.load_data())
+        self.weekly_check.start()
+
+    async def load_data(self):
+        path = Path(config.CYBERWARE_LOG_FILE)
+        self.data = await load_json_file(path, default={})
+
+    def cog_unload(self):
+        self.weekly_check.cancel()
+
+    def calculate_cost(self, level: str, weeks: int) -> int:
+        """Return the medication cost for a given cyberware level and streak."""
+        base = BASE_FACTOR[level]
+        cost = int(base * (2 ** (weeks - 1)))
+        return min(cost, MAX_COST[level])
+
+    @tasks.loop(time=time(hour=0, tzinfo=ZoneInfo(getattr(config, "TIMEZONE", "UTC"))))
+    async def weekly_check(self):
+        """Run every day and trigger processing each Saturday."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('cyberware'):
+            return
+        if datetime.now(ZoneInfo(getattr(config, "TIMEZONE", "UTC"))).weekday() != 5:  # Saturday
+            return
+        await self.process_week()
+
+    async def process_week(
+        self,
+        *,
+        dry_run: bool = False,
+        log: Optional[List[str]] = None,
+        target_member: Optional[discord.Member] = None,
+    ):
+        """Apply weekly check-up logic and deduct medication costs."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('cyberware'):
+            return
+        guild = self.bot.get_guild(config.GUILD_ID)
+        if not guild:
+            return
+
+        checkup_role = guild.get_role(config.CYBER_CHECKUP_ROLE_ID)
+        medium_role = guild.get_role(config.CYBER_MEDIUM_ROLE_ID)
+        high_role = guild.get_role(config.CYBER_HIGH_ROLE_ID)
+        extreme_role = guild.get_role(config.CYBER_EXTREME_ROLE_ID)
+        loa_role = guild.get_role(config.LOA_ROLE_ID)
+        log_channel = guild.get_channel(
+            getattr(config, "RIPPERDOC_LOG_CHANNEL_ID", config.RENT_LOG_CHANNEL_ID)
+        )
+
+        members = [target_member] if target_member else guild.members
+        for member in members:
+            if loa_role and loa_role in member.roles:
+                continue
+            role_level = None
+            if extreme_role and extreme_role in member.roles:
+                role_level = "extreme"
+            elif high_role and high_role in member.roles:
+                role_level = "high"
+            elif medium_role and medium_role in member.roles:
+                role_level = "medium"
+
+            user_id = str(member.id)
+            weeks = self.data.get(user_id, 0)
+
+            has_checkup = checkup_role in member.roles if checkup_role else False
+
+            if role_level is None:
+                if weeks:
+                    self.data.pop(user_id, None)
+                continue
+
+            if not has_checkup:
+                # Give the checkup role and reset streak without charging
+                if weeks:
+                    weeks = 0
+                if checkup_role:
+                    if not dry_run:
+                        await member.add_roles(checkup_role, reason="Weekly cyberware check")
+                    if log is not None:
+                        log.append(
+                            f"{'Would give' if dry_run else 'Gave'} checkup role to <@{member.id}>"
+                        )
+                if not dry_run:
+                    self.data[user_id] = 0
+                continue
+
+            # User kept the checkup role for another week → charge them
+            weeks += 1
+            cost = self.calculate_cost(role_level, weeks)
+            if log is not None:
+                log.append(f"Processing <@{member.id}> — week {weeks} cost ${cost}")
+            balance = await self.unbelievaboat.get_balance(member.id)
+            if not balance:
+                if log_channel and not dry_run:
+                    await log_channel.send(
+                        f"⚠️ Could not fetch balance for <@{member.id}> to process cyberware meds."
+                    )
+                if log is not None and dry_run:
+                    log.append(f"Would notify missing balance for <@{member.id}>")
+                continue
+
+            if dry_run:
+                check = await self.unbelievaboat.verify_balance_ops(member.id)
+                if log is not None:
+                    log.append("🔄 Balance check passed." if check else "⚠️ Balance update check failed.")
+
+            total = balance.get("cash", 0) + balance.get("bank", 0)
+            if total < cost:
+                if log_channel and not dry_run:
+                    await log_channel.send(
+                        f"🚨 <@{member.id}> cannot pay ${cost} for immunosuppressants and is in danger of cyberpsychosis."
+                    )
+                if log is not None and dry_run:
+                    log.append(
+                        f"Would warn insufficient funds for <@{member.id}> (${cost})"
+                    )
+            else:
+                success = True
+                if not dry_run:
+                    success = await self.unbelievaboat.update_balance(
+                        member.id, {"cash": -cost}, reason="Cyberware medication"
+                    )
+                if log_channel:
+                    if success and not dry_run:
+                        await log_channel.send(
+                            f"✅ Deducted ${cost} for cyberware meds from <@{member.id}> (week {weeks})."
+                        )
+                    elif not success and not dry_run:
+                        await log_channel.send(
+                            f"❌ Could not deduct ${cost} from <@{member.id}> for cyberware meds."
+                        )
+                if log is not None and dry_run:
+                    log.append(
+                        f"✅ Would deduct ${cost} from <@{member.id}> for cyberware meds (week {weeks})."
+                    )
+
+            if not dry_run:
+                self.data[user_id] = weeks
+            elif log is not None:
+                log.append(f"Streak would become {weeks} week(s) for <@{member.id}>")
+        if not dry_run:
+            await save_json_file(Path(config.CYBERWARE_LOG_FILE), self.data)
+        elif log is not None:
+            log.append("Simulation complete. No changes saved.")
+
+    @commands.command()
+    @commands.check_any(is_ripperdoc(), is_fixer(), commands.has_permissions(administrator=True))
+    async def simulate_cyberware(
+        self,
+        ctx,
+        member: Optional[str] = None,
+        weeks: Optional[int] = None,
+    ):
+        """Simulate weekly cyberware costs.
+
+        With no arguments, performs a full dry-run of the weekly process. When
+        ``member`` and ``weeks`` are provided, it simply calculates how much that
+        user would owe on the given week.
+        """
+
+        resolved_member: Optional[discord.Member] = None
+        if member:
+            try:
+                resolved_member = await commands.MemberConverter().convert(ctx, member)
+            except commands.BadArgument:
+                await ctx.send("❌ Could not resolve user.")
+                return
+
+        # Specific user/week cost preview
+        if resolved_member and weeks is not None:
+            guild = ctx.guild
+            medium_role = guild.get_role(config.CYBER_MEDIUM_ROLE_ID)
+            high_role = guild.get_role(config.CYBER_HIGH_ROLE_ID)
+            extreme_role = guild.get_role(config.CYBER_EXTREME_ROLE_ID)
+            level = None
+            if extreme_role and extreme_role in resolved_member.roles:
+                level = "extreme"
+            elif high_role and high_role in resolved_member.roles:
+                level = "high"
+            elif medium_role and medium_role in resolved_member.roles:
+                level = "medium"
+
+            if level is None:
+                await ctx.send(f"{resolved_member.display_name} has no cyberware role.")
+                return
+
+            cost = self.calculate_cost(level, weeks)
+            await ctx.send(
+                f"💊 {resolved_member.display_name} would pay ${cost} for week {weeks}."
+            )
+            return
+
+        # Global dry-run simulation or single-user when member is provided
+        logs: List[str] = []
+        await self.process_week(dry_run=True, log=logs, target_member=resolved_member)
+        summary = "\n".join(logs) if logs else "✅ Simulation complete."
+        await ctx.send(summary)
+        admin_cog = self.bot.get_cog('Admin')
+        if admin_cog:
+            await admin_cog.log_audit(ctx.author, summary)
+
+    @commands.command()
+    @is_ripperdoc()
+    async def checkup(self, ctx, member: discord.Member):
+        """Remove the weekly cyberware checkup role from a member."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('cyberware'):
+            await ctx.send("⚠️ The cyberware system is currently disabled.")
+            return
+        guild = ctx.guild
+        role = guild.get_role(config.CYBER_CHECKUP_ROLE_ID)
+        if role is None:
+            await ctx.send("⚠️ Checkup role is not configured.")
+            return
+
+        if role not in member.roles:
+            await ctx.send(f"{member.display_name} does not have the checkup role.")
+            return
+
+        await member.remove_roles(role, reason="Cyberware check-up completed")
+        await ctx.send(f"✅ Removed checkup role from {member.display_name}.")
+
+
+        log_channel = ctx.guild.get_channel(
+            getattr(config, "RIPPERDOC_LOG_CHANNEL_ID", config.RENT_LOG_CHANNEL_ID)
+        )
+        if log_channel:
+            await log_channel.send(
+                f"Ripperdoc {ctx.author.display_name} did a checkup on {member.display_name}"
+            )
+
+        self.data[str(member.id)] = 0
+        await save_json_file(Path(config.CYBERWARE_LOG_FILE), self.data)
+
+    @commands.command(aliases=["weekswithoutcheckup"])
+    @commands.check_any(is_ripperdoc(), is_fixer())
+    async def weeks_without_checkup(self, ctx, member: discord.Member):
+        """Show how many weeks a member has gone without a checkup."""
+        weeks = self.data.get(str(member.id), 0)
+        await ctx.send(f"{member.display_name} has gone {weeks} week(s) without a checkup.")
\ No newline at end of file
diff --git a/NightCityBot/cogs/dm_handling.py b/NightCityBot/cogs/dm_handling.py
index d846ed0..8273ecf 100644
--- a/NightCityBot/cogs/dm_handling.py
+++ b/NightCityBot/cogs/dm_handling.py
@@ -69,6 +69,10 @@ class DMHandler(commands.Cog):
         if message.author == self.bot.user or message.author.bot:
             return
 
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('dm'):
+            return
+
         # Handle relay from Fixer DM-forum threads
         if isinstance(message.channel, discord.Thread):
             await self.handle_thread_message(message)
@@ -91,6 +95,10 @@ class DMHandler(commands.Cog):
             if not target_user:
                 return
 
+            if message.content.strip().startswith("!"):
+                ctx = await self.bot.get_context(message)
+
+
             # Handle roll command relay
             if message.content.strip().lower().startswith("!roll"):
                 roll_cog = self.bot.get_cog('RollSystem')
@@ -107,6 +115,37 @@ class DMHandler(commands.Cog):
                     pass
                 return
 
+            # Handle start-rp command relay
+            if message.content.strip().lower().startswith("!start-rp"):
+                rp_cog = self.bot.get_cog('RPManager')
+                if rp_cog:
+                    args_str = message.content.strip()[len("!start-rp"):].strip()
+                    if args_str:
+                        args = args_str.split()
+                    else:
+                        args = [f"<@{target_user.id}>"]
+                    ctx = await self.bot.get_context(message)
+                    await rp_cog.start_rp(ctx, *args)
+                try:
+                    await message.delete()
+                except Exception:
+                    pass
+                return
+
+            if message.content.strip().startswith("!"):
+                ctx = await self.bot.get_context(message)
+                admin = self.bot.get_cog('Admin')
+                async def audit_send(content=None, **kwargs):
+                    if admin and content:
+                        await admin.log_audit(message.author, content)
+                ctx.send = audit_send
+                await self.bot.invoke(ctx)
+                try:
+                    await message.delete()
+                except Exception:
+                    pass
+                return
+
             # Handle normal message relay
             files = [await a.to_file() for a in message.attachments]
             await target_user.send(content=message.content or None, files=files)
@@ -121,6 +160,9 @@ class DMHandler(commands.Cog):
 
     async def handle_dm_message(self, message: discord.Message):
         """Handle incoming DMs from users."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('dm'):
+            return
         try:
             thread = await self.get_or_create_dm_thread(message.author)
             msg_target: Messageable = thread
@@ -142,6 +184,14 @@ class DMHandler(commands.Cog):
     @is_fixer()
     async def dm(self, ctx, user: discord.User, *, message=None):
         """Send an anonymous DM to a user."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('dm'):
+            await ctx.send("⚠️ The dm system is currently disabled.")
+            try:
+                await ctx.message.delete()
+            except Exception:
+                pass
+            return
         try:
             if not user:
                 raise ValueError("User fetch returned None.")
@@ -150,12 +200,20 @@ class DMHandler(commands.Cog):
             admin = self.bot.get_cog('Admin')
             if admin:
                 await admin.log_audit(ctx.author, "❌ Failed DM: Could not resolve user.")
+            try:
+                await ctx.message.delete()
+            except Exception:
+                pass
             return
         except Exception as e:
             await ctx.send(f"⚠️ Unexpected error: {str(e)}")
             admin = self.bot.get_cog('Admin')
             if admin:
                 await admin.log_audit(ctx.author, f"⚠️ Exception in DM: {str(e)}")
+            try:
+                await ctx.message.delete()
+            except Exception:
+                pass
             return
 
         file_links = [attachment.url for attachment in ctx.message.attachments]
@@ -172,7 +230,11 @@ class DMHandler(commands.Cog):
                 setattr(fake_ctx, "original_author", ctx.author)
                 await roll_cog.roll(fake_ctx, dice=dice)
                 await ctx.send(f"✅ Rolled `{dice}` anonymously for {user.display_name}.")
-                return
+            try:
+                await ctx.message.delete()
+            except Exception:
+                pass
+            return
 
         # Handle normal DM
         dm_content_parts = [message] if message else []
@@ -183,7 +245,6 @@ class DMHandler(commands.Cog):
 
         try:
             await user.send(content=dm_content)
-            await ctx.send(f'✅ DM sent anonymously to {user.display_name}.')
 
             thread = await self.get_or_create_dm_thread(user)
             if isinstance(thread, (discord.Thread, discord.TextChannel)):
@@ -193,8 +254,17 @@ class DMHandler(commands.Cog):
             else:
                 print(f"[ERROR] Cannot log DM — thread type is {type(thread)}")
 
+            admin = self.bot.get_cog('Admin')
+            if admin:
+                await admin.log_audit(ctx.author, f"✅ DM sent anonymously to {user.display_name}.")
+
         except discord.Forbidden:
             await ctx.send('❌ Cannot DM user (Privacy Settings).')
             admin = self.bot.get_cog('Admin')
             if admin:
                 await admin.log_audit(ctx.author, f"❌ Failed DM: Recipient: {user} (Privacy settings).")
+        finally:
+            try:
+                await ctx.message.delete()
+            except Exception:
+                pass
diff --git a/NightCityBot/cogs/economy.py b/NightCityBot/cogs/economy.py
index 54383dc..ca75419 100644
--- a/NightCityBot/cogs/economy.py
+++ b/NightCityBot/cogs/economy.py
@@ -1,6 +1,7 @@
 import discord
 from discord.ext import commands
 from datetime import datetime, timedelta
+from zoneinfo import ZoneInfo
 from typing import Optional, List, Dict
 from pathlib import Path
 import json
@@ -11,7 +12,9 @@ from NightCityBot.utils.constants import (
     ROLE_COSTS_HOUSING,
     BASELINE_LIVING_COST,
     TIER_0_INCOME_SCALE,
-    OPEN_PERCENT
+    OPEN_PERCENT,
+    ATTEND_REWARD,
+    TRAUMA_ROLE_COSTS,
 )
 from NightCityBot.utils.helpers import load_json_file, save_json_file
 import config
@@ -25,6 +28,9 @@ class Economy(commands.Cog):
         self.unbelievaboat = UnbelievaBoatAPI(config.UNBELIEVABOAT_API_TOKEN)
         self.trauma_service = TraumaTeamService(bot)
 
+    def cog_unload(self):
+        self.bot.loop.create_task(self.unbelievaboat.close())
+
     def calculate_passive_income(self, role: str, open_count: int) -> int:
         """Calculate passive income based on role and number of shop opens."""
         if role == "Business Tier 0":
@@ -44,10 +50,13 @@ class Economy(commands.Cog):
         total_income = 0
 
         member_id_str = str(member.id)
+        tz = ZoneInfo(getattr(config, "TIMEZONE", "UTC"))
+        now = datetime.now(tz)
         opens_this_month = [
-            ts for ts in business_open_log.get(member_id_str, [])
-            if datetime.fromisoformat(ts).month == datetime.utcnow().month and
-               datetime.fromisoformat(ts).year == datetime.utcnow().year
+            ts
+            for ts in business_open_log.get(member_id_str, [])
+            if datetime.fromisoformat(ts).month == now.month
+            and datetime.fromisoformat(ts).year == now.year
         ]
         open_count = min(len(opens_this_month), 4)
 
@@ -76,15 +85,23 @@ class Economy(commands.Cog):
             return current["cash"], current["bank"]
         return None, None
 
-    @commands.command()
+    @commands.command(aliases=["openshop"])
     @commands.has_permissions(send_messages=True)
     async def open_shop(self, ctx):
-        """Log a business opening (Sunday only)."""
+        """Log a business opening and grant income immediately."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('open_shop'):
+            await ctx.send("⚠️ The open_shop system is currently disabled.")
+            return
         if ctx.channel.id != config.BUSINESS_ACTIVITY_CHANNEL_ID:
             await ctx.send("❌ You can only log business openings in the designated business activity channel.")
             return
 
-        now = datetime.utcnow()
+        if not any(r.name.startswith("Business") for r in ctx.author.roles):
+            await ctx.send("❌ You must have a business role to use this command.")
+            return
+
+        now = datetime.now(ZoneInfo(getattr(config, "TIMEZONE", "UTC")))
         if now.weekday() != 6:
             await ctx.send("❌ Business openings can only be logged on Sundays.")
             return
@@ -106,17 +123,126 @@ class Economy(commands.Cog):
             await ctx.send("❌ You've already logged a business opening today.")
             return
 
-        if len(this_month_opens) >= 4:
-            await ctx.send("❌ You've already used all 4 business posts for this month.")
-            return
+        open_count_before = min(len(this_month_opens), 4)
+        open_count_after = min(open_count_before + 1, 4)
+        open_count_total = len(this_month_opens) + 1
 
         all_opens.append(now_str)
         data[user_id] = all_opens
         await save_json_file(config.OPEN_LOG_FILE, data)
 
-        await ctx.send(f"✅ Business opening logged! ({len(this_month_opens) + 1}/4 this month)")
+        reward = 0
+        role_names = [r.name for r in ctx.author.roles]
+        for role in role_names:
+            if "Business Tier" in role:
+                if role == "Business Tier 0":
+                    total_after = TIER_0_INCOME_SCALE.get(open_count_after, 0)
+                    total_before = TIER_0_INCOME_SCALE.get(open_count_before, 0)
+                else:
+                    base = ROLE_COSTS_BUSINESS.get(role, 500)
+                    total_after = int(base * OPEN_PERCENT[open_count_after])
+                    total_before = int(base * OPEN_PERCENT.get(open_count_before, 0))
+                reward += total_after - total_before
+
+        if reward > 0:
+            await self.unbelievaboat.update_balance(ctx.author.id, {"cash": reward}, reason="Business activity reward")
+            await ctx.send(f"✅ Business opening logged! You earned ${reward}. ({open_count_total} this month)")
+        else:
+            await ctx.send(f"✅ Business opening logged! ({open_count_total} this month)")
+
+    @commands.command()
+    async def attend(self, ctx):
+        """Log attendance for players with the verified role and award cash."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('attend'):
+            await ctx.send("⚠️ The attend system is currently disabled.")
+            return
+        if not any(r.id == config.VERIFIED_ROLE_ID for r in ctx.author.roles):
+            await ctx.send("❌ You must be verified to use this command.")
+            return
+
+        now = datetime.now(ZoneInfo(getattr(config, "TIMEZONE", "UTC")))
+        if now.weekday() != 6:
+            await ctx.send("❌ Attendance can only be logged on Sundays.")
+            return
+
+        user_id = str(ctx.author.id)
+        now_str = now.isoformat()
 
-    async def deduct_flat_fee(self, member: discord.Member, cash: int, bank: int, log: List[str], amount: int = BASELINE_LIVING_COST) -> tuple[bool, int, int]:
+        data = await load_json_file(config.ATTEND_LOG_FILE, default={})
+
+        all_logs = data.get(user_id, [])
+        parsed = [datetime.fromisoformat(ts) for ts in all_logs]
+        if parsed and (now - max(parsed)).days < 7:
+            await ctx.send("❌ You've already logged attendance this week.")
+            return
+
+        all_logs.append(now_str)
+        data[user_id] = all_logs
+        await save_json_file(config.ATTEND_LOG_FILE, data)
+
+        reward = ATTEND_REWARD
+        await self.unbelievaboat.update_balance(ctx.author.id, {"cash": reward}, reason="Attendance reward")
+        await ctx.send(f"✅ Attendance logged! You received ${reward}.")
+
+    def calculate_due(self, member: discord.Member) -> tuple[int, List[str]]:
+        """Calculate upcoming rent, baseline, and subscription costs."""
+        details: List[str] = []
+        total = 0
+        role_names = [r.name for r in member.roles]
+        loa_role = member.guild.get_role(config.LOA_ROLE_ID)
+        on_loa = loa_role in member.roles if loa_role else False
+
+        if on_loa:
+            details.append("LOA active: baseline, housing, and Trauma Team skipped")
+        else:
+            total += BASELINE_LIVING_COST
+            details.append(f"Baseline living cost: ${BASELINE_LIVING_COST}")
+            for role in role_names:
+                if "Housing Tier" in role:
+                    amount = ROLE_COSTS_HOUSING.get(role, 0)
+                    total += amount
+                    details.append(f"{role}: ${amount}")
+
+        for role in role_names:
+            if "Business Tier" in role:
+                amount = ROLE_COSTS_BUSINESS.get(role, 0)
+                total += amount
+                details.append(f"{role}: ${amount}")
+
+        if not on_loa:
+            trauma_role = next((r for r in member.roles if r.name in TRAUMA_ROLE_COSTS), None)
+            if trauma_role:
+                cost = TRAUMA_ROLE_COSTS[trauma_role.name]
+                total += cost
+                details.append(f"{trauma_role.name}: ${cost}")
+
+        return total, details
+
+    @commands.command(name="due")
+    async def due(self, ctx):
+        """Show estimated amount you will owe on the 1st of the month."""
+        print(
+            f"[DEBUG] due command invoked by {ctx.author} ({ctx.author.id})"
+            f" in {getattr(ctx.channel, 'name', ctx.channel.id)} ({ctx.channel.id})"
+        )
+        total, details = self.calculate_due(ctx.author)
+        lines = [f"💸 **Estimated Due:** ${total}"] + [f"• {d}" for d in details]
+        await ctx.send("\n".join(lines))
+
+    async def backup_balances(self, members: List[discord.Member], path: Path) -> None:
+        """Save current cash and bank balances for members."""
+        data: Dict[str, Dict[str, int]] = {}
+        for m in members:
+            bal = await self.unbelievaboat.get_balance(m.id)
+            if bal:
+                data[str(m.id)] = {
+                    "cash": bal.get("cash", 0),
+                    "bank": bal.get("bank", 0),
+                }
+        await save_json_file(path, data)
+
+    async def deduct_flat_fee(self, member: discord.Member, cash: int, bank: int, log: List[str], amount: int = BASELINE_LIVING_COST, *, dry_run: bool = False) -> tuple[bool, int, int]:
         total = (cash or 0) + (bank or 0)
         if total < amount:
             log.append(f"❌ Insufficient funds for flat fee deduction (${amount}). Current balance: ${total}.")
@@ -130,11 +256,16 @@ class Economy(commands.Cog):
         if deduct_bank > 0:
             payload["bank"] = -deduct_bank
 
-        success = await self.unbelievaboat.update_balance(member.id, payload, reason="Flat Monthly Fee")
+        success = True
+        if not dry_run:
+            success = await self.unbelievaboat.update_balance(member.id, payload, reason="Flat Monthly Fee")
         if success:
-            cash -= deduct_cash
-            bank -= deduct_bank
-            log.append(f"💸 Deducted flat monthly fee of ${amount} (Cash: ${deduct_cash}, Bank: ${deduct_bank}).")
+            if not dry_run:
+                cash -= deduct_cash
+                bank -= deduct_bank
+            log.append(
+                f"{'💸 Would deduct' if dry_run else '💸 Deducted'} flat monthly fee of ${amount} (Cash: ${deduct_cash}, Bank: ${deduct_bank})."
+            )
         else:
             log.append("❌ Failed to deduct flat monthly fee.")
 
@@ -148,8 +279,14 @@ class Economy(commands.Cog):
             bank: int,
             log: List[str],
             rent_log_channel: Optional[discord.TextChannel],
-            eviction_channel: Optional[discord.TextChannel]
+            eviction_channel: Optional[discord.TextChannel],
+            *,
+            dry_run: bool = False,
     ) -> tuple[int, int]:
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('housing_rent'):
+            log.append('⚠️ Housing rent system disabled.')
+            return cash, bank
         housing_total = 0
         for role in roles:
             if "Housing Tier" in role:
@@ -178,14 +315,21 @@ class Economy(commands.Cog):
         if deduct_bank > 0:
             payload["bank"] = -deduct_bank
 
-        success = await self.unbelievaboat.update_balance(member.id, payload, reason="Housing Rent")
+        success = True
+        if not dry_run:
+            success = await self.unbelievaboat.update_balance(member.id, payload, reason="Housing Rent")
         if success:
-            cash -= deduct_cash
-            bank -= deduct_bank
-            log.append(f"🧮 Subtracted housing rent ${housing_total} — ${deduct_cash} from cash, ${deduct_bank} from bank.")
-            log.append(f"📈 Balance after housing rent — Cash: ${cash:,}, Bank: ${bank:,}, Total: {(cash or 0) + (bank or 0):,}")
+            if not dry_run:
+                cash -= deduct_cash
+                bank -= deduct_bank
+            log.append(
+                f"🧮 {'Would subtract' if dry_run else 'Subtracted'} housing rent ${housing_total} — ${deduct_cash} from cash, ${deduct_bank} from bank."
+            )
+            log.append(
+                f"📈 Balance after housing rent — Cash: ${cash:,}, Bank: ${bank:,}, Total: {(cash or 0) + (bank or 0):,}"
+            )
             log.append("✅ Housing Rent collection completed. Notice Sent to #rent")
-            if rent_log_channel:
+            if rent_log_channel and not dry_run:
                 await rent_log_channel.send(f"✅ <@{member.id}> — Housing Rent paid: ${housing_total}")
         else:
             log.append("❌ Failed to deduct housing rent despite having sufficient funds.")
@@ -199,8 +343,14 @@ class Economy(commands.Cog):
             bank: int,
             log: List[str],
             rent_log_channel: Optional[discord.TextChannel],
-            eviction_channel: Optional[discord.TextChannel]
+            eviction_channel: Optional[discord.TextChannel],
+            *,
+            dry_run: bool = False,
     ) -> tuple[int, int]:
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('business_rent'):
+            log.append('⚠️ Business rent system disabled.')
+            return cash, bank
         business_total = 0
         for role in roles:
             if "Business Tier" in role:
@@ -229,26 +379,39 @@ class Economy(commands.Cog):
         if deduct_bank > 0:
             payload["bank"] = -deduct_bank
 
-        success = await self.unbelievaboat.update_balance(member.id, payload, reason="Business Rent")
+        success = True
+        if not dry_run:
+            success = await self.unbelievaboat.update_balance(member.id, payload, reason="Business Rent")
         if success:
-            cash -= deduct_cash
-            bank -= deduct_bank
-            log.append(f"🧮 Subtracted business rent ${business_total} — ${deduct_cash} from cash, ${deduct_bank} from bank.")
-            log.append(f"📈 Balance after business rent — Cash: ${cash:,}, Bank: ${bank:,}, Total: {(cash or 0) + (bank or 0):,}")
+            if not dry_run:
+                cash -= deduct_cash
+                bank -= deduct_bank
+            log.append(
+                f"🧮 {'Would subtract' if dry_run else 'Subtracted'} business rent ${business_total} — ${deduct_cash} from cash, ${deduct_bank} from bank."
+            )
+            log.append(
+                f"📈 Balance after business rent — Cash: ${cash:,}, Bank: ${bank:,}, Total: {(cash or 0) + (bank or 0):,}"
+            )
             log.append("✅ Business Rent collection completed. Notice Sent to #rent")
-            if rent_log_channel:
+            if rent_log_channel and not dry_run:
                 await rent_log_channel.send(f"✅ <@{member.id}> — Business Rent paid: ${business_total}")
         else:
             log.append("❌ Failed to deduct business rent despite having sufficient funds.")
         return cash, bank
 
-    @commands.command()
+    @commands.command(aliases=["collecthousing"])
     @commands.has_permissions(administrator=True)
     async def collect_housing(self, ctx, user: discord.Member):
         """Manually collect housing rent from a single user"""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('housing_rent'):
+            await ctx.send('⚠️ The housing_rent system is currently disabled.')
+            return
+        admin_cog = self.bot.get_cog('Admin')
         log: List[str] = [f"🏠 Manual Housing Rent Collection for <@{user.id}>"]
         rent_log_channel = ctx.guild.get_channel(config.RENT_LOG_CHANNEL_ID)
         eviction_channel = ctx.guild.get_channel(config.EVICTION_CHANNEL_ID)
+        await ctx.send(f"Working on <@{user.id}>")
 
         role_names = [r.name for r in user.roles]
         log.append(f"🧾 Roles: {role_names}")
@@ -256,7 +419,9 @@ class Economy(commands.Cog):
         balance_data = await self.unbelievaboat.get_balance(user.id)
         if not balance_data:
             log.append("❌ Could not fetch balance.")
-            await ctx.send("\n".join(log))
+            await ctx.send(f"⚠️ Could not fetch balance for <@{user.id}>")
+            if admin_cog:
+                await admin_cog.log_audit(ctx.author, "\n".join(log))
             return
 
         cash = balance_data["cash"]
@@ -271,17 +436,28 @@ class Economy(commands.Cog):
             final_cash = final.get("cash", 0)
             final_bank = final.get("bank", 0)
             final_total = final_cash + final_bank
-            log.append(f"📊 Final balance — Cash: ${final_cash:,}, Bank: ${final_bank:,}, Total: ${final_total:,}")
+            log.append(
+                f"📊 Final balance — Cash: ${final_cash:,}, Bank: ${final_bank:,}, Total: ${final_total:,}"
+            )
 
-        await ctx.send("\n".join(log))
+        summary = "\n".join(log)
+        await ctx.send(f"✅ Completed for <@{user.id}>")
+        if admin_cog:
+            await admin_cog.log_audit(ctx.author, summary)
 
-    @commands.command()
+    @commands.command(aliases=["collectbusiness"])
     @commands.has_permissions(administrator=True)
     async def collect_business(self, ctx, user: discord.Member):
         """Manually collect business rent from a single user"""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('business_rent'):
+            await ctx.send('⚠️ The business_rent system is currently disabled.')
+            return
+        admin_cog = self.bot.get_cog('Admin')
         log: List[str] = [f"🏢 Manual Business Rent Collection for <@{user.id}>"]
         rent_log_channel = ctx.guild.get_channel(config.RENT_LOG_CHANNEL_ID)
         eviction_channel = ctx.guild.get_channel(config.EVICTION_CHANNEL_ID)
+        await ctx.send(f"Working on <@{user.id}>")
 
         role_names = [r.name for r in user.roles]
         log.append(f"🧾 Roles: {role_names}")
@@ -289,7 +465,9 @@ class Economy(commands.Cog):
         balance_data = await self.unbelievaboat.get_balance(user.id)
         if not balance_data:
             log.append("❌ Could not fetch balance.")
-            await ctx.send("\n".join(log))
+            await ctx.send(f"⚠️ Could not fetch balance for <@{user.id}>")
+            if admin_cog:
+                await admin_cog.log_audit(ctx.author, "\n".join(log))
             return
 
         cash = balance_data["cash"]
@@ -304,19 +482,31 @@ class Economy(commands.Cog):
             final_cash = final.get("cash", 0)
             final_bank = final.get("bank", 0)
             final_total = final_cash + final_bank
-            log.append(f"📊 Final balance — Cash: ${final_cash:,}, Bank: ${final_bank:,}, Total: ${final_total:,}")
+            log.append(
+                f"📊 Final balance — Cash: ${final_cash:,}, Bank: ${final_bank:,}, Total: ${final_total:,}"
+            )
 
-        await ctx.send("\n".join(log))
+        summary = "\n".join(log)
+        await ctx.send(f"✅ Completed for <@{user.id}>")
+        if admin_cog:
+            await admin_cog.log_audit(ctx.author, summary)
 
-    @commands.command()
+    @commands.command(aliases=["collecttrauma"])
     @commands.has_permissions(administrator=True)
     async def collect_trauma(self, ctx, user: discord.Member):
         """Manually collect Trauma Team subscription"""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('trauma_team'):
+            await ctx.send('⚠️ The trauma_team system is currently disabled.')
+            return
+        admin_cog = self.bot.get_cog('Admin')
         log: List[str] = [f"💊 Manual Trauma Team Subscription Processing for <@{user.id}>"]
         balance_data = await self.unbelievaboat.get_balance(user.id)
         if not balance_data:
             log.append("❌ Could not fetch balance.")
-            await ctx.send("\n".join(log))
+            await ctx.send(f"⚠️ Could not fetch balance for <@{user.id}>")
+            if admin_cog:
+                await admin_cog.log_audit(ctx.author, "\n".join(log))
             return
 
         cash = balance_data["cash"]
@@ -324,6 +514,7 @@ class Economy(commands.Cog):
         total = (cash or 0) + (bank or 0)
         log.append(f"💵 Balance — Cash: ${cash:,}, Bank: ${bank:,}, Total: ${total:,}")
 
+        await ctx.send(f"Working on <@{user.id}>")
         await self.trauma_service.process_trauma_team_payment(user, log=log)
 
         final = await self.unbelievaboat.get_balance(user.id)
@@ -331,25 +522,46 @@ class Economy(commands.Cog):
             final_cash = final.get("cash", 0)
             final_bank = final.get("bank", 0)
             final_total = final_cash + final_bank
-            log.append(f"📊 Final balance — Cash: ${final_cash:,}, Bank: ${final_bank:,}, Total: ${final_total:,}")
+            log.append(
+                f"📊 Final balance — Cash: ${final_cash:,}, Bank: ${final_bank:,}, Total: ${final_total:,}"
+            )
 
-        await ctx.send("\n".join(log))
+        summary = "\n".join(log)
+        await ctx.send(f"✅ Completed for <@{user.id}>")
+        if admin_cog:
+            await admin_cog.log_audit(ctx.author, summary)
 
-    @commands.command()
-    @commands.has_permissions(administrator=True)
-    async def collect_rent(self, ctx, *, target_user: Optional[discord.Member] = None):
-        """Global or per-member rent collection."""
-        await ctx.send("🚦 Starting rent collection...")
+    async def run_rent_collection(
+        self,
+        ctx,
+        *,
+        target_user: Optional[discord.Member] = None,
+        dry_run: bool = False,
+        verbose: bool = False,
+    ):
+
+        """Internal helper for rent collection and simulation.
+
+        When ``verbose`` is ``False`` only minimal status messages are sent.
+        """
+        await ctx.send("🧪 Starting rent simulation..." if dry_run else "🚦 Starting rent collection...")
 
         if not target_user:
             if Path(config.OPEN_LOG_FILE).exists():
                 business_open_log = await load_json_file(config.OPEN_LOG_FILE, default={})
-                backup = f"open_history_{datetime.utcnow():%B_%Y}.json"
-                Path(config.OPEN_LOG_FILE).rename(backup)
+                if not dry_run:
+                    backup_base = f"open_history_{datetime.utcnow():%B_%Y}.json"
+                    backup_path = Path(backup_base)
+                    counter = 1
+                    while backup_path.exists():
+                        backup_path = Path(f"{backup_base}_{counter}")
+                        counter += 1
+                    Path(config.OPEN_LOG_FILE).rename(backup_path)
             else:
                 business_open_log = {}
 
-            await save_json_file(config.OPEN_LOG_FILE, {})
+            if not dry_run:
+                await save_json_file(config.OPEN_LOG_FILE, {})
         else:
             if Path(config.OPEN_LOG_FILE).exists():
                 business_open_log = await load_json_file(config.OPEN_LOG_FILE, default={})
@@ -362,7 +574,7 @@ class Economy(commands.Cog):
             if datetime.utcnow() - last_run < timedelta(days=30):
                 await ctx.send("⚠️ Rent already collected in the last 30 days.")
                 return
-        if not target_user:
+        if not target_user and not dry_run:
             with open(config.LAST_RENT_FILE, "w") as f:
                 json.dump({"last_run": datetime.utcnow().isoformat()}, f)
 
@@ -377,50 +589,72 @@ class Economy(commands.Cog):
             await ctx.send("❌ No matching members found.")
             return
 
+        backup_dir = Path(config.BALANCE_BACKUP_DIR)
+        backup_dir.mkdir(exist_ok=True)
+        backup_file = backup_dir / f"balances_{datetime.utcnow():%Y%m%d_%H%M%S}.json"
+        if not dry_run:
+            await self.backup_balances(members_to_process, backup_file)
+
         eviction_channel = ctx.guild.get_channel(config.EVICTION_CHANNEL_ID)
         rent_log_channel = ctx.guild.get_channel(config.RENT_LOG_CHANNEL_ID)
+        admin_cog = self.bot.get_cog('Admin')
 
         for member in members_to_process:
             try:
                 log: List[str] = [f"🔍 **Working on:** <@{member.id}>"]
+                if not verbose:
+                    await ctx.send(f"Working on <@{member.id}>")
 
                 role_names = [r.name for r in member.roles]
                 app_roles = [r for r in role_names if "Tier" in r]
                 log.append(f"🏷️ Detected roles: {', '.join(app_roles) or 'None'}")
 
+                loa_role = member.guild.get_role(config.LOA_ROLE_ID)
+                on_loa = loa_role in member.roles if loa_role else False
+                if on_loa:
+                    log.append("🏖️ Member is on LOA — skipping personal fees.")
+
                 bal = await self.unbelievaboat.get_balance(member.id)
                 if not bal:
                     log.append("⚠️ Could not fetch balance.")
-                    await ctx.send("\n".join(log))
+                    summary = "\n".join(log)
+                    if verbose:
+                        await ctx.send(summary)
+                    else:
+                        await ctx.send(f"⚠️ Could not fetch balance for <@{member.id}>")
+                    if dry_run and admin_cog:
+                        await admin_cog.log_audit(ctx.author, summary)
                     continue
                 cash, bank = bal["cash"], bal["bank"]
                 log.append(f"💵 Starting balance — Cash: ${cash:,}, Bank: ${bank:,}, Total: {(cash or 0) + (bank or 0):,}")
 
-                base_ok, cash, bank = await self.deduct_flat_fee(member, cash, bank, log, BASELINE_LIVING_COST)
-                if not base_ok:
-                    if eviction_channel:
-                        await eviction_channel.send(
-                            f"⚠️ <@{member.id}> could not pay baseline living cost (${BASELINE_LIVING_COST})."
-                        )
-                    log.append("❌ Skipping remaining rent steps.")
-                    await ctx.send("\n".join(log))
-                    continue
-
-                try:
-                    new_cash, new_bank = await self.apply_passive_income(member, app_roles, business_open_log, log)
-                    if new_cash is not None and new_bank is not None:
-                        cash, bank = new_cash, new_bank
-                    else:
-                        log.append("⚠️ Passive income failed to return balance. Using previous state.")
-                except RuntimeError as err:
-                    log.append(f"❌ {err}")
-                    await ctx.send("\n".join(log))
-                    continue
-
-                cash, bank = await self.process_housing_rent(member, app_roles, cash, bank, log, rent_log_channel, eviction_channel)
-                cash, bank = await self.process_business_rent(member, app_roles, cash, bank, log, rent_log_channel, eviction_channel)
-
-                await self.trauma_service.process_trauma_team_payment(member, log=log)
+                if dry_run:
+                    check = await self.unbelievaboat.verify_balance_ops(member.id)
+                    log.append("🔄 Balance check passed." if check else "⚠️ Balance update check failed.")
+
+                if not on_loa:
+                    base_ok, cash, bank = await self.deduct_flat_fee(member, cash, bank, log, BASELINE_LIVING_COST, dry_run=dry_run)
+                    if not base_ok:
+                        if eviction_channel:
+                            if not dry_run:
+                                await eviction_channel.send(
+                                    f"⚠️ <@{member.id}> could not pay baseline living cost (${BASELINE_LIVING_COST})."
+                                )
+                        log.append("❌ Skipping remaining rent steps.")
+                        summary = "\n".join(log)
+                        if verbose:
+                            await ctx.send(summary)
+                        else:
+                            await ctx.send(f"❌ Skipping remaining rent steps for <@{member.id}>")
+                        if dry_run and admin_cog:
+                            await admin_cog.log_audit(ctx.author, summary)
+                        continue
+
+                cash, bank = await self.process_housing_rent(member, app_roles, cash, bank, log, rent_log_channel, eviction_channel, dry_run=dry_run) if not on_loa else (cash, bank)
+                cash, bank = await self.process_business_rent(member, app_roles, cash, bank, log, rent_log_channel, eviction_channel, dry_run=dry_run)
+
+                if not on_loa:
+                    await self.trauma_service.process_trauma_team_payment(member, log=log, dry_run=dry_run)
 
                 final = await self.unbelievaboat.get_balance(member.id)
                 if final:
@@ -429,9 +663,80 @@ class Economy(commands.Cog):
 
                 log.append(f"📊 Final balance — Cash: ${cash:,}, Bank: ${bank:,}, Total: {(cash or 0) + (bank or 0):,}")
 
-                await ctx.send("\n".join(log))
+                summary = "\n".join(log)
+                if verbose:
+                    await ctx.send(summary)
+                else:
+                    await ctx.send(f"✅ Completed for <@{member.id}>")
+                if dry_run and admin_cog:
+                    await admin_cog.log_audit(ctx.author, summary)
 
             except Exception as e:
                 await ctx.send(f"❌ Error processing <@{member.id}>: `{e}`")
+                if dry_run and admin_cog:
+                    await admin_cog.log_audit(ctx.author, f"Error processing <@{member.id}>: {e}")
+
+        end_msg = "✅ Rent simulation completed." if dry_run else "✅ Rent collection completed."
+        await ctx.send(end_msg)
+        if dry_run and admin_cog:
+            await admin_cog.log_audit(ctx.author, end_msg)
+
+    @commands.command(aliases=["collectrent"])
+    @commands.has_permissions(administrator=True)
+    async def collect_rent(self, ctx, *args, target_user: Optional[discord.Member] = None):
+        """Global or per-member rent collection.
+
+        Pass ``-v``/``--verbose`` to include detailed output.
+        """
+        verbose = False
+        if target_user is None:
+            converter = commands.MemberConverter()
+            remaining = []
+            for arg in args:
+                if arg.lower() in {"-v", "--verbose", "-verbose", "verbose"}:
+                    verbose = True
+                else:
+                    remaining.append(arg)
+            for arg in remaining:
+                try:
+                    target_user = await converter.convert(ctx, arg)
+                    break
+                except commands.BadArgument:
+                    continue
+        else:
+            for arg in args:
+                if arg.lower() in {"-v", "--verbose", "-verbose", "verbose"}:
+                    verbose = True
+                    break
+        await self.run_rent_collection(ctx, target_user=target_user, dry_run=False, verbose=verbose)
+
+    @commands.command(aliases=["simulaterent"])
+    @commands.has_permissions(administrator=True)
+    async def simulate_rent(self, ctx, *args, target_user: Optional[discord.Member] = None):
+        """Simulate rent collection without applying changes.
+
+        Pass ``-v``/``--verbose`` to include detailed output.
+        """
+        verbose = False
+        if target_user is None:
+            converter = commands.MemberConverter()
+            remaining = []
+            for arg in args:
+                if arg.lower() in {"-v", "--verbose", "-verbose", "verbose"}:
+                    verbose = True
+                else:
+                    remaining.append(arg)
+            for arg in remaining:
+                try:
+                    target_user = await converter.convert(ctx, arg)
+                    break
+                except commands.BadArgument:
+                    continue
+        else:
+            for arg in args:
+                if arg.lower() in {"-v", "--verbose", "-verbose", "verbose"}:
+                    verbose = True
+                    break
+        await self.run_rent_collection(ctx, target_user=target_user, dry_run=True, verbose=verbose)
+
 
-        await ctx.send("✅ Rent collection completed.")
diff --git a/NightCityBot/cogs/loa.py b/NightCityBot/cogs/loa.py
new file mode 100644
index 0000000..76deb26
--- /dev/null
+++ b/NightCityBot/cogs/loa.py
@@ -0,0 +1,109 @@
+import logging
+import discord
+from discord.ext import commands
+from typing import Optional
+
+# ----------------------------------------------------------------------------
+# Helpers
+# ----------------------------------------------------------------------------
+
+def get_loa_role(guild: discord.Guild) -> Optional[discord.abc.Snowflake]:
+    """Return the LOA role from ``guild`` if it exists."""
+    logger.debug(
+        "Fetching LOA role %s from guild %s", config.LOA_ROLE_ID, guild
+    )
+    role = discord.Guild.get_role(guild, config.LOA_ROLE_ID)
+    if role is None:
+        logger.debug(
+            "LOA role %s not found in guild %s", config.LOA_ROLE_ID, guild
+        )
+    return role
+
+import config
+from NightCityBot.utils.permissions import is_fixer
+
+logger = logging.getLogger(__name__)
+
+
+class LOA(commands.Cog):
+    """Manage Leave of Absence status."""
+
+    def __init__(self, bot: commands.Bot):
+        self.bot = bot
+
+    def get_loa_role(self, guild: discord.Guild) -> Optional[discord.abc.Snowflake]:
+        """Wrapper around :func:`get_loa_role` for backwards compatibility."""
+        return get_loa_role(guild)
+
+    @commands.command(
+        aliases=["startloa", "loa_start", "loastart"]
+    )
+    async def start_loa(self, ctx, member: Optional[discord.Member] = None):
+        """Start a leave of absence. Fixers may specify a member."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('loa'):
+            logger.debug("start_loa blocked: system disabled")
+            await ctx.send("⚠️ The LOA system is currently disabled.")
+            return
+        guild = ctx.guild
+        logger.debug("start_loa invoked by %s for %s", ctx.author, member or ctx.author)
+        loa_role = self.get_loa_role(guild)
+        if loa_role is None:
+            logger.debug("start_loa aborted: no LOA role")
+            await ctx.send("⚠️ LOA role is not configured.")
+            return
+
+        target = member or ctx.author
+        if member and not any(r.name == config.FIXER_ROLE_NAME for r in ctx.author.roles):
+            logger.debug("start_loa denied: %s lacks fixer role", ctx.author)
+            await ctx.send("❌ Permission denied.")
+            return
+
+        # Compare by ID to avoid issues with mocked Role equality
+        if any(r.id == loa_role.id for r in target.roles):
+            logger.debug("%s already has LOA role", target)
+            await ctx.send(f"{target.display_name} is already on LOA.")
+            return
+
+        await target.add_roles(loa_role, reason="LOA start")
+        logger.debug("LOA role added to %s", target)
+        if target == ctx.author:
+            await ctx.send("✅ You are now on LOA.")
+        else:
+            await ctx.send(f"✅ {target.display_name} is now on LOA.")
+
+    @commands.command(
+        aliases=["endloa", "loa_end", "loaend"]
+    )
+    async def end_loa(self, ctx, member: Optional[discord.Member] = None):
+        """End a leave of absence. Fixers may specify a member."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('loa'):
+            await ctx.send("⚠️ The LOA system is currently disabled.")
+            return
+        guild = ctx.guild
+        logger.debug("end_loa invoked by %s for %s", ctx.author, member or ctx.author)
+        loa_role = self.get_loa_role(guild)
+        if loa_role is None:
+            logger.debug("end_loa aborted: no LOA role")
+            await ctx.send("⚠️ LOA role is not configured.")
+            return
+
+        target = member or ctx.author
+        if member and not any(r.name == config.FIXER_ROLE_NAME for r in ctx.author.roles):
+            logger.debug("end_loa denied: %s lacks fixer role", ctx.author)
+            await ctx.send("❌ Permission denied.")
+            return
+
+        # Compare by ID to avoid issues with mocked Role equality
+        if not any(r.id == loa_role.id for r in target.roles):
+            logger.debug("%s is not on LOA", target)
+            await ctx.send(f"{target.display_name} is not currently on LOA.")
+            return
+
+        await target.remove_roles(loa_role, reason="LOA end")
+        logger.debug("LOA role removed from %s", target)
+        if target == ctx.author:
+            await ctx.send("✅ Your LOA has ended.")
+        else:
+            await ctx.send(f"✅ {target.display_name}'s LOA has ended.")
diff --git a/NightCityBot/cogs/roll_system.py b/NightCityBot/cogs/roll_system.py
index ed411fc..1611e36 100644
--- a/NightCityBot/cogs/roll_system.py
+++ b/NightCityBot/cogs/roll_system.py
@@ -99,3 +99,4 @@ class RollSystem(commands.Cog):
                 await thread.send(
                     f"📤 **{original_sender.display_name} rolled as {author.display_name}** → `!roll {dice}`\n\n{result}"
                 )
+
diff --git a/NightCityBot/cogs/rp_manager.py b/NightCityBot/cogs/rp_manager.py
index 1a4cf7d..93027e0 100644
--- a/NightCityBot/cogs/rp_manager.py
+++ b/NightCityBot/cogs/rp_manager.py
@@ -1,4 +1,5 @@
 import re
+import logging
 import discord
 from discord.ext import commands
 from typing import Optional, List, cast
@@ -6,12 +7,35 @@ from NightCityBot.utils.permissions import is_fixer
 from NightCityBot.utils.helpers import build_channel_name
 import config
 
+logger = logging.getLogger(__name__)
+
 
 class RPManager(commands.Cog):
     def __init__(self, bot):
         self.bot = bot
 
-    @commands.command()
+    @commands.Cog.listener()
+    async def on_message(self, message: discord.Message):
+        if message.author == self.bot.user or message.author.bot:
+            return
+        if isinstance(message.channel, discord.TextChannel) and message.channel.name.startswith("text-rp-"):
+            if message.content.strip().startswith("!"):
+                ctx = await self.bot.get_context(message)
+                admin = self.bot.get_cog('Admin')
+                async def audit_send(content=None, **kwargs):
+                    if admin and content:
+                        await admin.log_audit(message.author, content)
+                ctx.send = audit_send
+                await self.bot.invoke(ctx)
+                try:
+                    await message.delete()
+                except Exception:
+                    pass
+                return
+
+    @commands.command(
+        aliases=["startrp", "rp_start", "rpstart"]
+    )
     @commands.has_permissions(administrator=True)
     async def start_rp(self, ctx, *user_identifiers: str):
         """Starts a private RP channel for the mentioned users."""
@@ -40,7 +64,9 @@ class RPManager(commands.Cog):
         await ctx.send(f"✅ RP channel created: {channel.mention}")
         return channel
 
-    @commands.command()
+    @commands.command(
+        aliases=["endrp", "rp_end", "rpend"]
+    )
     @is_fixer()
     async def end_rp(self, ctx):
         """Ends the RP session in the current channel."""
@@ -50,6 +76,7 @@ class RPManager(commands.Cog):
             return
 
         await ctx.send("📝 Ending RP session, logging contents and deleting channel...")
+        logger.debug("end_rp invoked by %s in %s", ctx.author, channel)
         await self.end_rp_session(channel)
 
     async def create_group_rp_channel(
@@ -82,38 +109,58 @@ class RPManager(commands.Cog):
             reason="Creating private RP group channel"
         )
 
-    async def end_rp_session(self, channel: discord.TextChannel):
-        """Archives and ends an RP session."""
+    async def end_rp_session(
+            self, channel: discord.TextChannel
+    ) -> Optional[discord.Thread]:
+        """Archive and end an RP session and return the created log thread."""
+        logger.debug("end_rp_session started for channel %s", channel)
         log_channel = channel.guild.get_channel(config.GROUP_AUDIT_LOG_CHANNEL_ID)
-        if not isinstance(log_channel, discord.ForumChannel):
-            await channel.send("⚠️ Logging failed: audit log channel is not a ForumChannel.")
-            return
-
-        participants = channel.name.replace("text-rp-", "").split("-")
-        thread_name = "GroupRP-" + "-".join(participants)
-
-        created = await log_channel.create_thread(
-            name=thread_name,
-            content=f"📘 RP log for `{channel.name}`"
-        )
-
-        log_thread = created.thread if hasattr(created, "thread") else created
-        log_thread = cast(discord.Thread, log_thread)
-
-        async for msg in channel.history(limit=None, oldest_first=True):
-            ts = msg.created_at.strftime("%Y-%m-%d %H:%M:%S")
-            content = msg.content or "*(No text content)*"
-            entry = f"[{ts}] 📥 **Received from {msg.author.display_name}**:\n{content}"
-
-            if msg.attachments:
-                for attachment in msg.attachments:
-                    entry += f"\n📎 Attachment: {attachment.url}"
-
-            if len(entry) <= 2000:
-                await log_thread.send(entry)
-            else:
-                chunks = [entry[i:i + 1990] for i in range(0, len(entry), 1990)]
-                for chunk in chunks:
-                    await log_thread.send(chunk)
-
-        await channel.delete(reason="RP session ended and logged.")
+        logger.debug("audit channel resolved as %s", log_channel)
+        try:
+            if not isinstance(log_channel, discord.ForumChannel):
+                await channel.send(
+                    "⚠️ Logging failed: audit log channel is not a ForumChannel. "
+                    "Deleting session without logging."
+                )
+                logger.debug(
+                    "audit channel invalid, deleting channel %s without logging",
+                    channel,
+                )
+                await channel.delete(reason="RP session ended without log channel")
+                return None
+
+            participants = channel.name.replace("text-rp-", "").split("-")
+            thread_name = "GroupRP-" + "-".join(participants)
+
+            logger.debug("creating log thread %s in %s", thread_name, log_channel)
+            created = await log_channel.create_thread(
+                name=thread_name,
+                content=f"📘 RP log for `{channel.name}`"
+            )
+
+            log_thread = created.thread if hasattr(created, "thread") else created
+            log_thread = cast(discord.Thread, log_thread)
+
+            async for msg in channel.history(limit=None, oldest_first=True):
+                ts = msg.created_at.strftime("%Y-%m-%d %H:%M:%S")
+                content = msg.content or "*(No text content)*"
+                entry = f"[{ts}] 📥 **Received from {msg.author.display_name}**:\n{content}"
+
+                if msg.attachments:
+                    for attachment in msg.attachments:
+                        entry += f"\n📎 Attachment: {attachment.url}"
+
+                if len(entry) <= 2000:
+                    await log_thread.send(entry)
+                else:
+                    chunks = [entry[i:i + 1990] for i in range(0, len(entry), 1990)]
+                    for chunk in chunks:
+                        await log_thread.send(chunk)
+
+            logger.debug("deleting RP channel %s after logging", channel)
+            await channel.delete(reason="RP session ended and logged.")
+            return log_thread
+        except Exception as e:
+            logger.exception("Failed to end RP session: %s", e)
+            await channel.send(f"⚠️ Error ending RP: {e}")
+            return None
diff --git a/NightCityBot/cogs/system_control.py b/NightCityBot/cogs/system_control.py
new file mode 100644
index 0000000..692a1c7
--- /dev/null
+++ b/NightCityBot/cogs/system_control.py
@@ -0,0 +1,72 @@
+import discord
+from discord.ext import commands
+from pathlib import Path
+import config
+from NightCityBot.utils.helpers import load_json_file, save_json_file
+
+SYSTEMS = [
+    "cyberware",
+    "attend",
+    "open_shop",
+    "loa",
+    "housing_rent",
+    "business_rent",
+    "trauma_team",
+    "dm",
+]
+
+class SystemControl(commands.Cog):
+    """Enable or disable major bot systems."""
+
+    def __init__(self, bot: commands.Bot):
+        self.bot = bot
+        self.status = {}
+        self.bot.loop.create_task(self.load_status())
+
+    async def load_status(self):
+        path = Path(config.SYSTEM_STATUS_FILE)
+        self.status = await load_json_file(path, default={})
+        updated = False
+        for system in SYSTEMS:
+            if system not in self.status:
+                self.status[system] = False
+                updated = True
+        if updated:
+            await save_json_file(path, self.status)
+
+    def is_enabled(self, system: str) -> bool:
+        return self.status.get(system, False)
+
+    async def set_status(self, system: str, value: bool):
+        if system not in SYSTEMS:
+            return False
+        self.status[system] = value
+        await save_json_file(Path(config.SYSTEM_STATUS_FILE), self.status)
+        return True
+
+    @commands.command(aliases=["enablesystem"])
+    @commands.has_permissions(administrator=True)
+    async def enable_system(self, ctx, system: str):
+        """Enable a disabled system."""
+        system = system.lower()
+        if not await self.set_status(system, True):
+            await ctx.send(f"❌ Unknown system '{system}'.")
+            return
+        await ctx.send(f"✅ Enabled {system} system.")
+
+    @commands.command(aliases=["disablesystem"])
+    @commands.has_permissions(administrator=True)
+    async def disable_system(self, ctx, system: str):
+        """Disable an active system."""
+        system = system.lower()
+        if not await self.set_status(system, False):
+            await ctx.send(f"❌ Unknown system '{system}'.")
+            return
+        await ctx.send(f"✅ Disabled {system} system.")
+
+    @commands.command(name="system_status", aliases=["systemstatus"])
+    @commands.has_permissions(administrator=True)
+    async def system_status(self, ctx):
+        """Show current system enablement."""
+        lines = [f"{name}: {'ON' if state else 'OFF'}" for name, state in self.status.items()]
+        await ctx.send("\n".join(lines))
diff --git a/NightCityBot/cogs/test_suite.py b/NightCityBot/cogs/test_suite.py
index ae82b3e..3c9a388 100644
--- a/NightCityBot/cogs/test_suite.py
+++ b/NightCityBot/cogs/test_suite.py
@@ -1,39 +1,34 @@
 import discord
 from discord.ext import commands
 import time
-from datetime import datetime
-import os
+import asyncio
 import sys
 from pathlib import Path
+import logging
 
 # Ensure the project root is on the path for `import config` and utility modules
 ROOT_DIR = Path(__file__).resolve().parents[2]
 if str(ROOT_DIR) not in sys.path:
     sys.path.insert(0, str(ROOT_DIR))
 from typing import List, Dict, Optional
-from unittest.mock import AsyncMock, MagicMock
+from unittest.mock import AsyncMock, MagicMock, patch
 import config
-from NightCityBot.utils.permissions import is_fixer
-from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+from NightCityBot import tests
+
+logger = logging.getLogger(__name__)
 
 class TestSuite(commands.Cog):
     def __init__(self, bot):
         self.bot = bot
-        self.test_descriptions = {
-            "test_dm_roll_relay": "Relays a roll to a user's DM forum thread using `!dm`.",
-            "test_roll_direct_dm": "User runs `!roll` in a DM. Verifies result is DM'd and logged to DM thread.",
-            "test_post_executes_command": "Sends a `!roll` command into a channel using `!post`.",
-            "test_post_roll_execution": "Executes a roll via !post and checks result inside RP channel.",
-            "test_rolls": "Runs `!roll` with valid and invalid input and checks result.",
-            "test_bonus_rolls": "Checks that Netrunner bonuses are applied correctly.",
-            "test_full_rent_commands": "Executes rent collection on a live user and verifies balance updates.",
-            "test_passive_income_logic": "Applies passive income based on recent shop opens.",
-            "test_trauma_payment": "Attempts to log a trauma plan subscription in the correct DM thread.",
-            "test_rent_logging_sends": "Verifies that rent events are logged in #rent and #eviction-notices.",
-            "test_open_shop_command": "Runs !open_shop in the correct channel.",
-            "test_dm_thread_reuse": "Ensures DM logging reuses existing threads.",
-            "test_open_shop_errors": "Checks open_shop failures for bad context.",
-        }
+        self.tests = tests.TEST_FUNCTIONS
+        self.test_descriptions = tests.TEST_DESCRIPTIONS
+        self.verbose = False
+
+    def debug(self, logs: List[str], message: str) -> None:
+        """Append a debug message when verbose output is enabled."""
+        if self.verbose:
+            logs.append(f"🔍 {message}")
 
     async def get_test_user(self, ctx) -> Optional[discord.Member]:
         """Get or fetch the test user."""
@@ -42,355 +37,179 @@ class TestSuite(commands.Cog):
             user = await ctx.guild.fetch_member(config.TEST_USER_ID)
         return user
 
-    def assert_send(self, logs: List[str], mock_obj, label: str) -> None:
-        """Assert that send was called on a mock object."""
+    def assert_called(self, logs: List[str], mock_obj, label: str) -> None:
+        """Assert that an awaited call was made on the given mock."""
         try:
-            mock_obj.send.assert_awaited()
-            logs.append(f"✅ {label}.send was called")
+            mock_obj.assert_awaited()
+            logs.append(f"✅ {label} was called")
         except AssertionError:
-            logs.append(f"❌ {label}.send was not called")
-
-    async def test_dm_roll_relay(self, ctx) -> List[str]:
-        """Test relaying roll commands through DMs."""
-        logs = []
-        try:
-            user = await self.get_test_user(ctx)
-            dm_handler = self.bot.get_cog('DMHandler')
-            thread = await dm_handler.get_or_create_dm_thread(user)
-            roll_system = self.bot.get_cog('RollSystem')
-            await roll_system.loggable_roll(user, thread, "1d20", original_sender=ctx.author)
-            logs.append("✅ !dm @user !roll d20 relay succeeded")
-
-            try:
-                dm_channel = await user.create_dm()
-                await dm_channel.send("✅ DM test message from NightCityBotTest.")
-                logs.append("✅ Direct DM sent to user.")
-            except discord.Forbidden:
-                logs.append("⚠️ Could not DM user — Privacy settings?")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_dm_roll_relay: {e}")
-        return logs
-
-    async def test_roll_direct_dm(self, ctx) -> List[str]:
-        """Test roll command in direct DMs."""
-        logs = []
-        try:
-            user = await self.get_test_user(ctx)
-            dm_channel = await user.create_dm()
-
-            logs.append("→ Expected: !roll in DM should send a result and log it to the user's DM thread.")
-
-            roll_system = self.bot.get_cog('RollSystem')
-            await roll_system.loggable_roll(user, dm_channel, "1d6")
-            logs.append("→ Result: ✅ !roll executed in user DM context.")
-
-        except Exception as e:
-            logs.append(f"❌ Exception in test_roll_direct_dm: {e}")
-        return logs
-
-    async def test_post_executes_command(self, ctx) -> List[str]:
-        """Test posting commands to channels."""
-        logs = []
-        try:
-            rp_channel = ctx.test_rp_channel
-            ctx.message.attachments = []
-            admin_cog = self.bot.get_cog('Admin')
-            await admin_cog.post(ctx, rp_channel.name, message="!roll 1d4")
-            logs.append("✅ !post executed and command sent in reused RP channel")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_post_executes_command: {e}")
-        return logs
-
-    async def test_post_roll_execution(self, ctx) -> List[str]:
-        """Test roll execution via post command."""
-        logs = []
-        try:
-            thread = ctx.test_rp_channel
-            admin_cog = self.bot.get_cog('Admin')
-            await admin_cog.post(ctx, thread.name, message="!roll 1d20+1")
-            logs.append("✅ !post <thread> !roll d20+1 executed in reused RP channel")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_post_roll_execution: {e}")
-        return logs
-
-    async def test_rolls(self, ctx) -> List[str]:
-        """Test roll command functionality."""
-        logs = []
-        try:
-            logs.append("→ Expected: Valid roll should return a total, invalid roll should return a format error.")
-
-            roll_system = self.bot.get_cog('RollSystem')
-            # Valid roll
-            await roll_system.loggable_roll(ctx.author, ctx.channel, "1d20+2")
-            logs.append("→ Result (Valid): ✅ Roll succeeded and result sent.")
-
-            # Invalid roll
-            await roll_system.loggable_roll(ctx.author, ctx.channel, "notadice")
-            logs.append("→ Result (Invalid): ✅ Error message shown for invalid format.")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_rolls: {e}")
-        return logs
-
-    async def test_bonus_rolls(self, ctx) -> List[str]:
-        """Test roll bonuses for Netrunner roles."""
-        logs = []
-        mock_author = AsyncMock(spec=discord.Member)
-        mock_author.display_name = "BonusTest"
-        mock_author.roles = [AsyncMock(name="Netrunner Level 2")]
-        for r in mock_author.roles:
-            r.name = "Netrunner Level 2"
-
-        channel = AsyncMock(spec=discord.TextChannel)
-        channel.send = AsyncMock()
-
-        logs.append("→ Expected: Roll result should include '+1 Netrunner bonus' in output.")
-
-        try:
-            roll_system = self.bot.get_cog('RollSystem')
-            await roll_system.loggable_roll(mock_author, channel, "1d20")
-            message = channel.send.call_args[0][0]
-            if "+1 Netrunner bonus" in message:
-                logs.append("→ Result: ✅ Found bonus text in roll output.")
-            else:
-                logs.append("→ Result: ❌ Bonus text missing from roll output.")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_bonus_rolls: {e}")
-        return logs
-
-    async def test_full_rent_commands(self, ctx) -> List[str]:
-        """Test all rent-related commands."""
-        logs = []
-        try:
-            user = await self.get_test_user(ctx)
-            logs.append("→ Expected: All rent-related commands should complete without error.")
-
-            if os.path.exists(config.LAST_RENT_FILE):
-                os.remove(config.LAST_RENT_FILE)
-
-            economy = self.bot.get_cog('Economy')
-            await economy.collect_rent(ctx)
-            logs.append("✅ collect_rent (global) executed")
-
-            if os.path.exists(config.LAST_RENT_FILE):
-                os.remove(config.LAST_RENT_FILE)
-
-            await economy.collect_rent(ctx, target_user=user)
-            logs.append("✅ collect_rent (specific user) executed")
-
-            await economy.collect_housing(ctx, user)
-            logs.append("✅ collect_housing executed")
-
-            await economy.collect_business(ctx, user)
-            logs.append("✅ collect_business executed")
-
-            await economy.collect_trauma(ctx, user)
-            logs.append("✅ collect_trauma executed")
-
-            logs.append("→ Result: ✅ All rent commands executed.")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_full_rent_commands: {e}")
-        return logs
-
-    async def test_passive_income_logic(self, ctx) -> List[str]:
-        """Test passive income calculations."""
-        logs = []
-        user = await self.get_test_user(ctx)
-        economy = self.bot.get_cog('Economy')
-
-        for role in ROLE_COSTS_BUSINESS.keys():
-            for open_count in range(5):  # 0 to 4 opens
-                now = datetime.utcnow().isoformat()
-                business_open_log = {str(user.id): [now] * open_count}
-                applicable_roles = [role]
-                test_log = []
-
-                expected_income = economy.calculate_passive_income(role, open_count)
-                logs.append(f"→ {role} with {open_count} open(s): Expect ${expected_income}")
-
-                await economy.apply_passive_income(user, applicable_roles, business_open_log, test_log)
+            logs.append(f"❌ {label} was not called")
 
-                expected_log = f"💰 Passive income for {role}: ${expected_income} ({open_count} opens)"
-                found_log_line = expected_log in test_log
-                if found_log_line:
-                    logs.append(f"✅ Found income log: `{expected_log}`")
-                else:
-                    logs.append(f"❌ Missing income log: Expected `{expected_log}`, got: {test_log}")
-
-                added_line = f"➕ Added ${expected_income} passive income."
-                if expected_income > 0:
-                    if any(added_line in line for line in test_log):
-                        logs.append(f"✅ Found balance update line: `{added_line}`")
-                    else:
-                        logs.append(f"❌ Missing balance update: Expected `{added_line}`")
-                else:
-                    if any("➕ Added" in line for line in test_log):
-                        logs.append(f"❌ Unexpected balance update for $0 income")
-                    else:
-                        logs.append(f"✅ No balance update (correct for $0 income)")
-
-        return logs
-
-    async def test_trauma_payment(self, ctx) -> List[str]:
-        """Test Trauma Team subscription processing."""
-        logs = []
-        try:
-            user = await self.get_test_user(ctx)
-            logs.append("→ Expected: collect_trauma should find thread and log subscription payment.")
-
-            economy = self.bot.get_cog('Economy')
-            await economy.collect_trauma(ctx, user)
-            logs.append("→ Result: ✅ Trauma Team logic executed on live user (check #tt-plans-payment).")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_trauma_payment: {e}")
-        return logs
-
-    async def test_rent_logging_sends(self, ctx) -> List[str]:
-        """Test rent logging functionality."""
-        logs = []
-        try:
-            user = await self.get_test_user(ctx)
-            rent_log_channel = ctx.guild.get_channel(config.RENT_LOG_CHANNEL_ID)
-            eviction_channel = ctx.guild.get_channel(config.EVICTION_CHANNEL_ID)
-
-            logs.append("→ Expected: collect_rent should post messages to rent and eviction log channels.")
-
-            if not rent_log_channel or not eviction_channel:
-                logs.append("→ Result: ❌ Rent or eviction channels not found.")
-                return logs
-
-            economy = self.bot.get_cog('Economy')
-            await economy.collect_rent(ctx, target_user=user)
-            logs.append("→ Result: ✅ Rent logic executed and logging channels present.")
-        except Exception as e:
-            logs.append(f"❌ Exception in test_rent_logging_sends: {e}")
-        return logs
-
-    async def test_open_shop_command(self, ctx) -> List[str]:
-        """Test shop opening functionality."""
-        logs = []
+    def assert_send(self, logs: List[str], mock_obj, label: str) -> None:
+        """Assert that a send-like coroutine was awaited."""
         try:
-            correct_channel = ctx.guild.get_channel(config.BUSINESS_ACTIVITY_CHANNEL_ID)
-            logs.append("→ Expected: !open_shop should succeed when run inside the business channel.")
-
-            if not correct_channel:
-                logs.append("→ Result: ❌ Business open channel not found")
-                return logs
-
-            original_channel = ctx.channel
-            ctx.channel = correct_channel
-
-            economy = self.bot.get_cog('Economy')
-            await economy.open_shop(ctx)
-            logs.append("→ Result: ✅ !open_shop executed in correct channel")
-
-            ctx.channel = original_channel
-        except Exception as e:
-            logs.append(f"❌ Exception in test_open_shop_command: {e}")
-        return logs
-
-    async def test_dm_thread_reuse(self, ctx) -> List[str]:
-        """Ensure DM threads are reused instead of duplicated."""
-        logs = []
-        user = await self.get_test_user(ctx)
-        dm_handler = self.bot.get_cog('DMHandler')
-        first = await dm_handler.get_or_create_dm_thread(user)
-        second = await dm_handler.get_or_create_dm_thread(user)
-        if first.id == second.id:
-            logs.append("✅ DM thread reused correctly")
-        else:
-            logs.append("❌ DM thread was recreated")
-        return logs
-
-    async def test_open_shop_errors(self, ctx) -> List[str]:
-        """Verify open_shop fails in wrong channel or on wrong day."""
-        logs = []
-        economy = self.bot.get_cog('Economy')
-        wrong_channel = ctx.channel
-        # Wrong channel
-        await economy.open_shop(ctx)
-        logs.append("✅ open_shop rejected outside business channel")
-        # Simulate correct channel but non-Sunday
-        ctx.channel = ctx.guild.get_channel(config.BUSINESS_ACTIVITY_CHANNEL_ID)
-        if datetime.utcnow().weekday() == 6:
-            logs.append("⚠️ Test run on Sunday; skip non-Sunday check")
-        else:
-            await economy.open_shop(ctx)
-            logs.append("✅ open_shop rejected on non-Sunday")
-        ctx.channel = wrong_channel
-        return logs
+            mock_obj.assert_awaited()
+            logs.append(f"✅ {label} was called")
+        except AssertionError:
+            logs.append(f"❌ {label} was not called")
 
-    @commands.command(hidden=True)
+    @commands.command(hidden=True, aliases=["testbot"])
     @commands.is_owner()
-    async def test_bot(self, ctx):
-        """Run all bot tests."""
+    async def test_bot(self, ctx, *test_names: str):
+        """Run bot self tests."""
         start = time.time()
         all_logs = []
 
         # Create a reusable RP channel for tests
-        rp_manager = self.bot.get_cog('RPManager')
-        rp_channel = await rp_manager.start_rp(ctx, f"<@{config.TEST_USER_ID}>")
-        ctx.test_rp_channel = rp_channel
+        test_names = list(test_names)
+        silent = False
+        verbose = False
+        if "-silent" in test_names:
+            test_names.remove("-silent")
+            silent = True
+        if "-verbose" in test_names:
+            test_names.remove("-verbose")
+            verbose = True
+
+        self.verbose = verbose
+        ctx.verbose = verbose
 
         output_channel = ctx.channel
+        if silent:
+            output_channel = await ctx.author.create_dm()
+            await ctx.send("🧪 Running tests in silent mode. Results will be sent via DM.")
+            ctx.send = AsyncMock()
+
         ctx.message.attachments = []
 
-        await output_channel.send(f"🧪 Running full self-test on user <@{config.TEST_USER_ID}>...")
+        rp_required_tests = {
+            "test_post_executes_command",
+            "test_post_roll_execution",
+        }
 
-        tests = [
-            ("test_dm_roll_relay", self.test_dm_roll_relay),
-            ("test_roll_direct_dm", self.test_roll_direct_dm),
-            ("test_post_executes_command", self.test_post_executes_command),
-            ("test_post_roll_execution", self.test_post_roll_execution),
-            ("test_rolls", self.test_rolls),
-            ("test_bonus_rolls", self.test_bonus_rolls),
-            ("test_full_rent_commands", self.test_full_rent_commands),
-            ("test_passive_income_logic", self.test_passive_income_logic),
-            ("test_trauma_payment", self.test_trauma_payment),
-            ("test_rent_logging_sends", self.test_rent_logging_sends),
-            ("test_open_shop_command", self.test_open_shop_command),
-            ("test_dm_thread_reuse", self.test_dm_thread_reuse),
-            ("test_open_shop_errors", self.test_open_shop_errors),
-        ]
+        if test_names:
+            await output_channel.send(
+                f"🧪 Running selected tests on <@{config.TEST_USER_ID}>: {', '.join(test_names)}"
+            )
+        else:
+            await output_channel.send(
+                f"🧪 Running full self-test on user <@{config.TEST_USER_ID}>..."
+            )
+
+        tests = list(self.tests.items())
+        tests_dict = self.tests
+
+        if test_names:
+            filtered = []
+            unknown = []
+            for name in test_names:
+                if name in tests_dict:
+                    filtered.append((name, tests_dict[name]))
+                else:
+                    unknown.append(name)
+            if unknown:
+                await output_channel.send(
+                    f"⚠️ Unknown tests: {', '.join(unknown)}"
+                )
+            tests = filtered
+            if not tests:
+                return
 
-        for name, func in tests:
-            await output_channel.send(f"🧪 `{name}` — {self.test_descriptions.get(name, 'No description.')}")
-            try:
-                logs = await func(ctx)
-            except Exception as e:
-                logs = [f"❌ Exception in `{name}`: {e}"]
-            all_logs.append(f"{name} — {self.test_descriptions.get(name, '')}")
-            all_logs.extend(logs)
-            all_logs.append("────────────")
+        rp_manager = self.bot.get_cog('RPManager')
+        rp_channel = None
+        needs_rp = (not test_names) or any(name in rp_required_tests for name, _ in tests)
+        if needs_rp:
+            rp_channel = await rp_manager.start_rp(ctx, f"<@{config.TEST_USER_ID}>")
+        ctx.test_rp_channel = rp_channel
 
-        # Send results in chunks
-        current_chunk = ""
-        for line in all_logs:
-            line = str(line)
-            if len(current_chunk) + len(line) + 1 > 1900:
-                await output_channel.send(f"```\n{current_chunk.strip()}\n```")
-                current_chunk = line
+        try:
+            for name, func in tests:
+                if verbose:
+                    await output_channel.send(
+                        f"🧪 `{name}` — {self.test_descriptions.get(name, 'No description.')}"
+                    )
+                try:
+                    logs = await func(self, ctx)
+                except Exception as e:
+                    logs = [f"❌ Exception in `{name}`: {e}"]
+                all_logs.append(f"{name} — {self.test_descriptions.get(name, '')}")
+                all_logs.extend(logs)
+                all_logs.append("────────────")
+
+            if verbose:
+                # Send results in chunks
+                current_chunk = ""
+                for line in all_logs:
+                    line = str(line)
+                    if len(current_chunk) + len(line) + 1 > 1900:
+                        await output_channel.send(f"```\n{current_chunk.strip()}\n```")
+                        current_chunk = line
+                    else:
+                        current_chunk += line + "\n"
+                if current_chunk:
+                    await output_channel.send(f"```\n{current_chunk.strip()}\n```")
             else:
-                current_chunk += line + "\n"
-        if current_chunk:
-            await output_channel.send(f"```\n{current_chunk.strip()}\n```")
-
-        # Summary embed
-        passed = sum(1 for r in all_logs if "✅" in r)
-        failed = sum(1 for r in all_logs if "❌" in r)
-        duration = time.time() - start
-
-        embed = discord.Embed(
-            title="🧪 Full Bot Self-Test Summary",
-            color=discord.Color.green() if failed == 0 else discord.Color.red()
-        )
-        embed.add_field(
-            name="Result",
-            value=f"✅ Passed: {passed}\n❌ Failed: {failed}",
-            inline=False
-        )
-        embed.set_footer(text=f"⏱️ Completed in {duration:.2f}s")
-        await output_channel.send(embed=embed)
-
-        # Cleanup test channel
-        if ctx.test_rp_channel:
-            await rp_manager.end_rp_session(ctx.test_rp_channel)
+                summary_text = "\n".join(str(l) for l in all_logs).strip()
+                current_chunk = ""
+                for line in summary_text.split("\n"):
+                    if len(current_chunk) + len(line) + 1 > 1900:
+                        await output_channel.send(f"```\n{current_chunk.strip()}\n```")
+                        current_chunk = line
+                    else:
+                        current_chunk += line + "\n"
+                if current_chunk:
+                    await output_channel.send(f"```\n{current_chunk.strip()}\n```")
+
+            # Summary embed
+            passed = sum(1 for r in all_logs if "✅" in r)
+            failed = sum(1 for r in all_logs if "❌" in r)
+            duration = time.time() - start
+
+            title = "🧪 Full Bot Self-Test Summary" if not test_names else "🧪 Selected Test Summary"
+            embed = discord.Embed(
+                title=title,
+                color=discord.Color.green() if failed == 0 else discord.Color.red()
+            )
+            embed.add_field(
+                name="Result",
+                value=f"✅ Passed: {passed}\n❌ Failed: {failed}",
+                inline=False
+            )
+            embed.set_footer(text=f"⏱️ Completed in {duration:.2f}s")
+            await output_channel.send(embed=embed)
+        finally:
+            if ctx.test_rp_channel:
+                logger.debug("Cleaning up test RP channel %s", ctx.test_rp_channel)
+                thread = await rp_manager.end_rp_session(ctx.test_rp_channel)
+                if thread:
+                    try:
+                        await thread.delete(reason="Test cleanup")
+                    except Exception:
+                        logger.exception("Failed to delete log thread %s", thread)
+            for ch in ctx.guild.text_channels:
+                if ch.name.startswith("text-rp-") and ch != ctx.test_rp_channel:
+                    try:
+                        logger.debug("Cleaning residual RP channel %s", ch)
+                        thread = await rp_manager.end_rp_session(ch)
+                        if thread:
+                            try:
+                                await thread.delete(reason="Test cleanup")
+                            except Exception:
+                                logger.exception("Failed to delete log thread %s", thread)
+                    except Exception:
+                        logger.exception("Failed to clean RP channel %s", ch)
+
+    @commands.command(hidden=True, name="test__bot")
+    @commands.is_owner()
+    async def test__bot(self, ctx, *patterns: str):
+        """Run the self tests through PyTest."""
+        import pytest
+        await ctx.send("🧪 Running tests with PyTest...")
+        args = ["-q", str(Path(__file__).resolve().parents[1] / "tests")]
+        if patterns:
+            args.extend(["-k", " or ".join(patterns)])
+        result = await asyncio.to_thread(pytest.main, args)
+        if result == 0:
+            await ctx.send("✅ PyTest finished successfully.")
+        else:
+            await ctx.send(f"❌ PyTest exited with code {result}.")
diff --git a/NightCityBot/services/trauma_team.py b/NightCityBot/services/trauma_team.py
index a27281b..2f94e26 100644
--- a/NightCityBot/services/trauma_team.py
+++ b/NightCityBot/services/trauma_team.py
@@ -12,9 +12,19 @@ class TraumaTeamService:
             self,
             member: discord.Member,
             *,
-            log: Optional[List[str]] = None
+            log: Optional[List[str]] = None,
+            dry_run: bool = False,
     ) -> None:
         """Process Trauma Team subscription payment for a member."""
+        control = self.bot.get_cog('SystemControl')
+        if control and not control.is_enabled('trauma_team'):
+            if log is not None:
+                log.append('⚠️ Trauma Team system disabled.')
+            return
+        if any(r.id == config.LOA_ROLE_ID for r in member.roles):
+            if log is not None:
+                log.append("🛑 Skipping Trauma payment due to LOA.")
+            return
         trauma_channel = self.bot.get_channel(config.TRAUMA_FORUM_CHANNEL_ID)
         if not isinstance(trauma_channel, discord.ForumChannel):
             if log is not None:
@@ -33,7 +43,7 @@ class TraumaTeamService:
         trauma_role = next(
             (r for r in member.roles if r.name in TRAUMA_ROLE_COSTS),
             None
-        )
+                )
         if not trauma_role:
             return  # no subscription
 
@@ -55,10 +65,11 @@ class TraumaTeamService:
 
         if cash + bank < cost:
             mention = f"<@&{config.TRAUMA_TEAM_ROLE_ID}>"
-            await target_thread.send(
-                f"❌ Payment for **{trauma_role.name}** (${cost}) by <@{member.id}> failed."
-                f"\n## {mention} Subscription suspended."
-            )
+            if not dry_run:
+                await target_thread.send(
+                    f"❌ Payment for **{trauma_role.name}** (${cost}) by <@{member.id}> failed."
+                    f"\n## {mention} Subscription suspended."
+                )
             if log is not None:
                 log.append("❌ Insufficient funds for Trauma payment.")
             return
@@ -67,21 +78,27 @@ class TraumaTeamService:
             "cash": -min(cash, cost),
             "bank": -(cost - min(cash, cost)),
         }
-        success = await self.bot.get_cog('Economy').unbelievaboat.update_balance(
-            member.id,
-            payload,
-            reason="Trauma Team Subscription"
-        )
+        success = True
+        if not dry_run:
+            success = await self.bot.get_cog('Economy').unbelievaboat.update_balance(
+                member.id,
+                payload,
+                reason="Trauma Team Subscription"
+            )
 
         if success:
-            await target_thread.send(
-                f"✅ **Payment Successful** — <@{member.id}> paid `${cost}` for **{trauma_role.name}** coverage."
-            )
+            if not dry_run:
+                await target_thread.send(
+                    f"✅ **Payment Successful** — <@{member.id}> paid `${cost}` for **{trauma_role.name}** coverage."
+                )
             if log is not None:
-                log.append("✅ Trauma Team payment completed. Notice Sent to users #tt-plans-payment thread.")
+                log.append(
+                    "✅ Trauma Team payment completed." if not dry_run else "✅ (Simulated) Trauma Team payment would succeed."
+                )
         else:
-            await target_thread.send(
-                f"⚠️ **Deduction failed** for <@{member.id}> despite available funds."
-            )
+            if not dry_run:
+                await target_thread.send(
+                    f"⚠️ **Deduction failed** for <@{member.id}> despite available funds."
+                )
             if log is not None:
                 log.append("⚠️ PATCH failed for Trauma Team payment.")
diff --git a/NightCityBot/services/unbelievaboat.py b/NightCityBot/services/unbelievaboat.py
index 8f7f274..2268de1 100644
--- a/NightCityBot/services/unbelievaboat.py
+++ b/NightCityBot/services/unbelievaboat.py
@@ -3,22 +3,25 @@ from typing import Dict, Optional
 import config
 
 class UnbelievaBoatAPI:
-    def __init__(self, api_token: str):
+    def __init__(self, api_token: str, session: Optional[aiohttp.ClientSession] = None):
         self.api_token = api_token
         self.base_url = f"https://unbelievaboat.com/api/v1/guilds/{config.GUILD_ID}"
         self.headers = {
             "Authorization": api_token,
             "Content-Type": "application/json"
         }
+        self.session = session or aiohttp.ClientSession()
+
+    async def close(self) -> None:
+        await self.session.close()
 
     async def get_balance(self, user_id: int) -> Optional[Dict]:
         """Get a user's balance from UnbelievaBoat."""
         url = f"{self.base_url}/users/{user_id}"
-        async with aiohttp.ClientSession() as session:
-            async with session.get(url, headers=self.headers) as resp:
-                if resp.status == 200:
-                    return await resp.json()
-                return None
+        async with self.session.get(url, headers=self.headers) as resp:
+            if resp.status == 200:
+                return await resp.json()
+            return None
 
     async def update_balance(
         self,
@@ -31,9 +34,16 @@ class UnbelievaBoatAPI:
         payload = amount_dict.copy()
         payload["reason"] = reason
 
-        async with aiohttp.ClientSession() as session:
-            async with session.patch(url, headers=self.headers, json=payload) as resp:
-                if resp.status != 200:
-                    error = await resp.text()
-                    print(f"❌ PATCH failed: {resp.status} — {error}")
-                return resp.status == 200
+        async with self.session.patch(url, headers=self.headers, json=payload) as resp:
+            if resp.status != 200:
+                error = await resp.text()
+                print(f"❌ PATCH failed: {resp.status} — {error}")
+            return resp.status == 200
+
+    async def verify_balance_ops(self, user_id: int) -> bool:
+        """Test updating a balance without affecting the final amount."""
+        minus = await self.update_balance(user_id, {"cash": -1}, reason="Simulation check")
+        if not minus:
+            return False
+        plus = await self.update_balance(user_id, {"cash": 1}, reason="Simulation check")
+        return minus and plus
diff --git a/NightCityBot/tests/__init__.py b/NightCityBot/tests/__init__.py
new file mode 100644
index 0000000..8a9b873
--- /dev/null
+++ b/NightCityBot/tests/__init__.py
@@ -0,0 +1,49 @@
+from importlib import import_module
+from typing import Callable, Dict
+
+TEST_FUNCTIONS: Dict[str, Callable] = {}
+TEST_DESCRIPTIONS: Dict[str, str] = {}
+
+# List of test module names and descriptions
+TEST_MODULES = {
+    "test_dm_roll_relay": "Relays a roll to a user's DM forum thread using `!dm`.",
+    "test_roll_direct_dm": "User runs `!roll` in a DM. Verifies result is DM'd and logged to DM thread.",
+    "test_post_executes_command": "Sends a `!roll` command into a channel using `!post`.",
+    "test_post_roll_execution": "Executes a roll via !post and checks result inside RP channel.",
+    "test_rolls": "Runs `!roll` with valid and invalid input and checks result.",
+    "test_bonus_rolls": "Checks that Netrunner bonuses are applied correctly.",
+    "test_full_rent_commands": "Executes rent collection on a live user and verifies balance updates.",
+    "test_passive_income_logic": "Applies passive income based on recent shop opens.",
+    "test_trauma_payment": "Attempts to log a trauma plan subscription in the correct DM thread.",
+    "test_rent_logging_sends": "Verifies that rent events are logged in #rent and #eviction-notices.",
+    "test_open_shop_command": "Runs !open_shop in the correct channel.",
+    "test_dm_thread_reuse": "Ensures DM logging reuses existing threads.",
+    "test_open_shop_errors": "Checks open_shop failures for bad context.",
+    "test_start_end_rp": "Creates and ends an RP session to verify logging.",
+    "test_unknown_command": "Ensures unknown commands don't spam the audit log.",
+    "test_ignore_unbelievaboat": "Ignores UnbelievaBoat economy commands.",
+    "test_open_shop_daily_limit": "Ensures !open_shop can't run twice on the same Sunday.",
+    "test_attend_command": "Runs !attend and verifies weekly/Sunday restrictions.",
+    "test_cyberware_costs": "Ensures cyberware medication costs scale and cap correctly.",
+    "test_loa_commands": "Runs start_loa and end_loa commands.",
+    "test_checkup_command": "Runs the ripperdoc !checkup command.",
+    "test_help_commands": "Executes !helpme and !helpfixer.",
+    "test_post_dm_channel": "Runs !post from a DM thread.",
+    "test_post_roll_as_user": "Executes a roll as another user via !post.",
+    "test_dm_plain": "Sends a normal anonymous DM using !dm.",
+    "test_dm_roll_command": "Relays a roll through !dm.",
+    "test_dm_userid": "Ensures !dm works with a raw user ID.",
+    "test_start_rp_multi": "Starts RP with two users and ends it.",
+    "test_cyberware_weekly": "Simulates the weekly cyberware task.",
+    "test_loa_fixer_other": "Fixer starts and ends LOA for another user.",
+    "test_loa_id_check": "Handles LOA with distinct role instances sharing an ID.",
+    "test_roll_as_user": "Rolls on behalf of another user.",
+    "test_message_cleanup": "Ensures !dm and !post delete their commands.",
+    "test_balance_backup": "Ensures collect_rent backs up balances before processing.",
+    "test_test_bot_dm": "Runs test_bot in silent mode and checks DM output.",
+}
+
+for name in TEST_MODULES:
+    mod = import_module(f"NightCityBot.tests.{name}")
+    TEST_FUNCTIONS[name] = mod.run
+    TEST_DESCRIPTIONS[name] = TEST_MODULES[name]
diff --git a/NightCityBot/tests/test_alias_registry.py b/NightCityBot/tests/test_alias_registry.py
new file mode 100644
index 0000000..6733694
--- /dev/null
+++ b/NightCityBot/tests/test_alias_registry.py
@@ -0,0 +1,32 @@
+import inspect
+from NightCityBot.cogs.loa import LOA
+from NightCityBot.cogs.rp_manager import RPManager
+from NightCityBot.cogs.economy import Economy
+from NightCityBot.cogs.cyberware import CyberwareManager
+from NightCityBot.cogs.system_control import SystemControl
+from NightCityBot.cogs.test_suite import TestSuite
+from NightCityBot.cogs.dm_handling import DMHandler
+import discord
+import pytest
+
+@pytest.mark.parametrize("cls, method, aliases", [
+    (LOA, "start_loa", ["startloa", "loa_start", "loastart"]),
+    (LOA, "end_loa", ["endloa", "loa_end", "loaend"]),
+    (RPManager, "start_rp", ["startrp", "rp_start", "rpstart"]),
+    (RPManager, "end_rp", ["endrp", "rp_end", "rpend"]),
+    (Economy, "open_shop", ["openshop"]),
+    (Economy, "collect_rent", ["collectrent"]),
+    (Economy, "collect_housing", ["collecthousing"]),
+    (Economy, "collect_business", ["collectbusiness"]),
+    (Economy, "collect_trauma", ["collecttrauma"]),
+    (CyberwareManager, "weeks_without_checkup", ["weekswithoutcheckup"]),
+    (SystemControl, "enable_system", ["enablesystem"]),
+    (SystemControl, "disable_system", ["disablesystem"]),
+    (SystemControl, "system_status", ["systemstatus"]),
+    (TestSuite, "test_bot", ["testbot"]),
+])
+def test_aliases(cls, method, aliases):
+    command = getattr(cls, method)
+    assert hasattr(command, "aliases"), f"{method} missing aliases"
+    for a in aliases:
+        assert a in command.aliases
diff --git a/NightCityBot/tests/test_attend_command.py b/NightCityBot/tests/test_attend_command.py
new file mode 100644
index 0000000..4618103
--- /dev/null
+++ b/NightCityBot/tests/test_attend_command.py
@@ -0,0 +1,81 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+from datetime import datetime, timedelta
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test the attend reward command and its restrictions."""
+    control = suite.bot.get_cog('SystemControl')
+    if control:
+        await control.set_status('attend', True)
+    logs = []
+    economy = suite.bot.get_cog('Economy')
+    original_author = ctx.author
+    mock_author = MagicMock(spec=discord.Member)
+    mock_author.id = original_author.id
+    mock_author.roles = [discord.Object(id=config.VERIFIED_ROLE_ID)]
+    ctx.author = mock_author
+    ctx.send = AsyncMock()
+
+    # Non-Sunday should be rejected
+    monday = datetime(2025, 6, 16)
+    with (
+        patch("NightCityBot.cogs.economy.datetime") as mock_dt,
+        patch("NightCityBot.cogs.economy.load_json_file", new=AsyncMock(return_value={})),
+        patch("NightCityBot.cogs.economy.save_json_file", new=AsyncMock()),
+    ):
+        mock_dt.now.return_value = monday
+        mock_dt.fromisoformat = datetime.fromisoformat
+        await economy.attend(ctx)
+        msg = ctx.send.await_args[0][0]
+        if "only be logged on Sundays" in msg:
+            logs.append("✅ attend rejected on non-Sunday")
+        else:
+            logs.append("❌ attend did not reject non-Sunday")
+    ctx.send.reset_mock()
+
+    # Already attended this week should be rejected
+    sunday = datetime(2025, 6, 15)
+    prev = sunday - timedelta(days=3)
+    with (
+        patch("NightCityBot.cogs.economy.datetime") as mock_dt,
+        patch(
+            "NightCityBot.cogs.economy.load_json_file",
+            new=AsyncMock(return_value={str(mock_author.id): [prev.isoformat()]}),
+        ),
+        patch("NightCityBot.cogs.economy.save_json_file", new=AsyncMock()),
+    ):
+        mock_dt.now.return_value = sunday
+        mock_dt.fromisoformat = datetime.fromisoformat
+        await economy.attend(ctx)
+        msg = ctx.send.await_args[0][0]
+        if "already logged attendance this week" in msg:
+            logs.append("✅ attend rejected when used twice")
+        else:
+            logs.append("❌ attend did not enforce weekly limit")
+    ctx.send.reset_mock()
+
+    # Success when a week has passed
+    prev2 = sunday - timedelta(days=7)
+    with (
+        patch("NightCityBot.cogs.economy.datetime") as mock_dt,
+        patch(
+            "NightCityBot.cogs.economy.load_json_file",
+            new=AsyncMock(return_value={str(mock_author.id): [prev2.isoformat()]}),
+        ),
+        patch("NightCityBot.cogs.economy.save_json_file", new=AsyncMock()),
+        patch.object(economy.unbelievaboat, "update_balance", new=AsyncMock()),
+    ):
+        mock_dt.now.return_value = sunday
+        mock_dt.fromisoformat = datetime.fromisoformat
+        await economy.attend(ctx)
+        msg = ctx.send.await_args[0][0]
+        if "Attendance logged" in msg:
+            logs.append("✅ attend succeeded after cooldown")
+        else:
+            logs.append("❌ attend did not succeed after cooldown")
+
+    ctx.author = original_author
+    return logs
diff --git a/NightCityBot/tests/test_balance_backup.py b/NightCityBot/tests/test_balance_backup.py
new file mode 100644
index 0000000..2fd0b10
--- /dev/null
+++ b/NightCityBot/tests/test_balance_backup.py
@@ -0,0 +1,18 @@
+from typing import List
+from unittest.mock import AsyncMock, patch
+import config
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure collect_rent backs up member balances."""
+    logs = []
+    user = await suite.get_test_user(ctx)
+    economy = suite.bot.get_cog('Economy')
+    ctx.send = AsyncMock()
+    with (
+        patch.object(economy.unbelievaboat, "get_balance", new=AsyncMock(return_value={"cash": 1000, "bank": 0})),
+        patch.object(economy.unbelievaboat, "update_balance", new=AsyncMock(return_value=True)),
+        patch.object(economy, "backup_balances", new=AsyncMock()) as mock_backup,
+    ):
+        await economy.collect_rent(ctx, target_user=user)
+        suite.assert_called(logs, mock_backup, "backup_balances")
+    return logs
diff --git a/NightCityBot/tests/test_bonus_rolls.py b/NightCityBot/tests/test_bonus_rolls.py
new file mode 100644
index 0000000..8cce51c
--- /dev/null
+++ b/NightCityBot/tests/test_bonus_rolls.py
@@ -0,0 +1,31 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test roll bonuses for Netrunner roles."""
+    logs = []
+    mock_author = AsyncMock(spec=discord.Member)
+    mock_author.display_name = "BonusTest"
+    mock_author.roles = [AsyncMock(name="Netrunner Level 2")]
+    for r in mock_author.roles:
+        r.name = "Netrunner Level 2"
+
+    channel = AsyncMock(spec=discord.TextChannel)
+    channel.send = AsyncMock()
+
+    logs.append("→ Expected: Roll result should include '+1 Netrunner bonus' in output.")
+
+    try:
+        roll_system = suite.bot.get_cog('RollSystem')
+        await roll_system.loggable_roll(mock_author, channel, "1d20")
+        message = channel.send.call_args[0][0]
+        if "+1 Netrunner bonus" in message:
+            logs.append("→ Result: ✅ Found bonus text in roll output.")
+        else:
+            logs.append("→ Result: ❌ Bonus text missing from roll output.")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_bonus_rolls: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_checkup_command.py b/NightCityBot/tests/test_checkup_command.py
new file mode 100644
index 0000000..d954bf2
--- /dev/null
+++ b/NightCityBot/tests/test_checkup_command.py
@@ -0,0 +1,35 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Run the ripperdoc checkup command."""
+    control = suite.bot.get_cog('SystemControl')
+    if control:
+        await control.set_status('cyberware', True)
+    logs = []
+    cyber = suite.bot.get_cog('CyberwareManager')
+    if not cyber:
+        logs.append("❌ CyberwareManager cog not loaded")
+        return logs
+    member = MagicMock(spec=discord.Member)
+    member.display_name = "TestUser"
+    member.roles = [discord.Object(id=config.CYBER_CHECKUP_ROLE_ID)]
+    member.remove_roles = AsyncMock()
+    log_channel = MagicMock()
+    log_channel.send = AsyncMock()
+    with (
+        patch("discord.Guild.get_role", return_value=discord.Object(id=config.CYBER_CHECKUP_ROLE_ID)),
+        patch("discord.Guild.get_channel", return_value=log_channel),
+        patch("NightCityBot.cogs.cyberware.save_json_file", new=AsyncMock()),
+    ):
+        await cyber.checkup.callback(cyber, ctx, member)
+    suite.assert_send(logs, member.remove_roles, "remove_roles")
+    suite.assert_send(logs, log_channel.send, "log_channel.send")
+    if cyber.data.get(str(member.id), 0) == 0:
+        logs.append("✅ checkup streak reset")
+    else:
+        logs.append("❌ checkup streak not reset")
+    return logs
diff --git a/NightCityBot/tests/test_cyberware_costs.py b/NightCityBot/tests/test_cyberware_costs.py
new file mode 100644
index 0000000..bf9823d
--- /dev/null
+++ b/NightCityBot/tests/test_cyberware_costs.py
@@ -0,0 +1,23 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Verify cyberware medication cost escalation."""
+    logs = []
+    manager = suite.bot.get_cog('CyberwareManager')
+    if not manager:
+        logs.append("❌ CyberwareManager cog not loaded")
+        return logs
+    try:
+        week1 = manager.calculate_cost('medium', 1)
+        week8 = manager.calculate_cost('extreme', 8)
+        if week1 < week8 == 10000:
+            logs.append("✅ Cyberware costs escalate and cap correctly")
+        else:
+            logs.append(f"❌ Unexpected cost results: week1={week1}, week8={week8}")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_cyberware_costs: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_cyberware_weekly.py b/NightCityBot/tests/test_cyberware_weekly.py
new file mode 100644
index 0000000..35b2a58
--- /dev/null
+++ b/NightCityBot/tests/test_cyberware_weekly.py
@@ -0,0 +1,41 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Simulate the weekly checkup task."""
+    logs: List[str] = []
+    manager = suite.bot.get_cog('CyberwareManager')
+    if not manager:
+        logs.append("❌ CyberwareManager cog not loaded")
+        return logs
+    guild = MagicMock()
+    check = discord.Object(id=config.CYBER_CHECKUP_ROLE_ID)
+    medium = discord.Object(id=config.CYBER_MEDIUM_ROLE_ID)
+    loa = discord.Object(id=config.LOA_ROLE_ID)
+    guild.get_role.side_effect = lambda rid: {config.CYBER_CHECKUP_ROLE_ID: check,
+                                              config.CYBER_MEDIUM_ROLE_ID: medium, config.LOA_ROLE_ID: loa}.get(rid)
+    member_a = MagicMock(spec=discord.Member)
+    member_a.id = 1
+    member_a.roles = [medium]
+    member_a.add_roles = AsyncMock()
+    member_b = MagicMock(spec=discord.Member)
+    member_b.id = 2
+    member_b.roles = [medium, check]
+    member_b.add_roles = AsyncMock()
+    guild.members = [member_a, member_b]
+    log_channel = MagicMock()
+    log_channel.send = AsyncMock()
+    guild.get_channel.return_value = log_channel
+    with (
+        patch.object(suite.bot, "get_guild", return_value=guild),
+        patch.object(manager.unbelievaboat, "get_balance", new=AsyncMock(return_value={"cash": 5000, "bank": 0})),
+        patch.object(manager.unbelievaboat, "update_balance", new=AsyncMock(return_value=True)),
+        patch("NightCityBot.cogs.cyberware.save_json_file", new=AsyncMock()),
+    ):
+        await manager.process_week()
+    suite.assert_send(logs, member_a.add_roles, "add_roles")
+    suite.assert_send(logs, log_channel.send, "log_channel.send")
+    return logs
diff --git a/NightCityBot/tests/test_dm_plain.py b/NightCityBot/tests/test_dm_plain.py
new file mode 100644
index 0000000..24a20cf
--- /dev/null
+++ b/NightCityBot/tests/test_dm_plain.py
@@ -0,0 +1,18 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Send an anonymous DM."""
+    logs: List[str] = []
+    dm = suite.bot.get_cog('DMHandler')
+    user = await suite.get_test_user(ctx)
+    ctx.send = AsyncMock()
+    ctx.message.attachments = []
+    with patch.object(type(user), "send", wraps=user.send) as send_mock:
+        with patch.object(dm, "get_or_create_dm_thread", new=AsyncMock(return_value=MagicMock(spec=discord.Thread))):
+            await dm.dm.callback(dm, ctx, user, message="Hello there!")
+        suite.assert_send(logs, send_mock, "user.send")
+    return logs
diff --git a/NightCityBot/tests/test_dm_roll_command.py b/NightCityBot/tests/test_dm_roll_command.py
new file mode 100644
index 0000000..b0cbac4
--- /dev/null
+++ b/NightCityBot/tests/test_dm_roll_command.py
@@ -0,0 +1,16 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Relay a roll through !dm."""
+    logs: List[str] = []
+    dm = suite.bot.get_cog('DMHandler')
+    user = await suite.get_test_user(ctx)
+    ctx.send = AsyncMock()
+    with patch.object(suite.bot.get_cog('RollSystem'), "roll", new=AsyncMock()) as mock_roll:
+        await dm.dm.callback(dm, ctx, user, message="!roll 1d20")
+    suite.assert_called(logs, mock_roll, "roll")
+    return logs
diff --git a/NightCityBot/tests/test_dm_roll_relay.py b/NightCityBot/tests/test_dm_roll_relay.py
new file mode 100644
index 0000000..c958ba1
--- /dev/null
+++ b/NightCityBot/tests/test_dm_roll_relay.py
@@ -0,0 +1,27 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test relaying roll commands through DMs."""
+    logs = []
+    try:
+        user = await suite.get_test_user(ctx)
+        dm_handler = suite.bot.get_cog('DMHandler')
+        dummy_thread = MagicMock(spec=discord.Thread)
+        dm_channel = MagicMock(spec=discord.DMChannel)
+        dm_channel.send = AsyncMock()
+        roll_cog = suite.bot.get_cog('RollSystem')
+        with (
+            patch.object(dm_handler, "get_or_create_dm_thread", new=AsyncMock(return_value=dummy_thread)),
+            patch.object(roll_cog, "loggable_roll", wraps=roll_cog.loggable_roll) as mock_roll,
+            patch.object(discord.Member, "create_dm", new=AsyncMock(return_value=dm_channel)),
+        ):
+            await dm_handler.dm.callback(dm_handler, ctx, user, message="!roll 1d20")
+            suite.assert_send(logs, dm_channel.send, "dm.send")
+        suite.assert_called(logs, mock_roll, "loggable_roll")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_dm_roll_relay: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_dm_thread_reuse.py b/NightCityBot/tests/test_dm_thread_reuse.py
new file mode 100644
index 0000000..b102262
--- /dev/null
+++ b/NightCityBot/tests/test_dm_thread_reuse.py
@@ -0,0 +1,21 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure DM threads are reused instead of duplicated."""
+    logs = []
+    user = await suite.get_test_user(ctx)
+    dm_handler = suite.bot.get_cog('DMHandler')
+    dummy_thread = MagicMock()
+    with patch.object(dm_handler, 'get_or_create_dm_thread', new=AsyncMock(return_value=dummy_thread)) as mock_get:
+        first = await dm_handler.get_or_create_dm_thread(user)
+        second = await dm_handler.get_or_create_dm_thread(user)
+    if first is second:
+        logs.append("✅ DM thread reused correctly")
+    else:
+        logs.append("❌ DM thread was recreated")
+    suite.assert_called(logs, mock_get, 'get_or_create_dm_thread')
+    return logs
diff --git a/NightCityBot/tests/test_dm_userid.py b/NightCityBot/tests/test_dm_userid.py
new file mode 100644
index 0000000..e07a03f
--- /dev/null
+++ b/NightCityBot/tests/test_dm_userid.py
@@ -0,0 +1,21 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure !dm works with a raw user ID."""
+    logs: List[str] = []
+    dm = suite.bot.get_cog('DMHandler')
+    user = await suite.get_test_user(ctx)
+    dummy = MagicMock(spec=discord.User)
+    dummy.id = user.id
+    dummy.display_name = user.display_name
+    ctx.send = AsyncMock()
+    ctx.message.attachments = []
+    with patch.object(type(dummy), "send", wraps=dummy.send) as send_mock:
+        with patch.object(dm, "get_or_create_dm_thread", new=AsyncMock(return_value=MagicMock(spec=discord.Thread))):
+            await dm.dm.callback(dm, ctx, dummy, message="Test")
+        suite.assert_send(logs, send_mock, "user.send")
+    return logs
diff --git a/NightCityBot/tests/test_full_rent_commands.py b/NightCityBot/tests/test_full_rent_commands.py
new file mode 100644
index 0000000..9a24a74
--- /dev/null
+++ b/NightCityBot/tests/test_full_rent_commands.py
@@ -0,0 +1,40 @@
+from typing import List
+import discord
+import os
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test all rent-related commands."""
+    logs = []
+    try:
+        user = await suite.get_test_user(ctx)
+        logs.append("→ Expected: All rent-related commands should complete without error.")
+
+        if os.path.exists(config.LAST_RENT_FILE):
+            os.remove(config.LAST_RENT_FILE)
+
+        economy = suite.bot.get_cog('Economy')
+        await economy.collect_rent(ctx)
+        logs.append("✅ collect_rent (global) executed")
+
+        if os.path.exists(config.LAST_RENT_FILE):
+            os.remove(config.LAST_RENT_FILE)
+
+        await economy.collect_rent(ctx, target_user=user)
+        logs.append("✅ collect_rent (specific user) executed")
+
+        await economy.collect_housing(ctx, user)
+        logs.append("✅ collect_housing executed")
+
+        await economy.collect_business(ctx, user)
+        logs.append("✅ collect_business executed")
+
+        await economy.collect_trauma(ctx, user)
+        logs.append("✅ collect_trauma executed")
+
+        logs.append("→ Result: ✅ All rent commands executed.")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_full_rent_commands: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_help_commands.py b/NightCityBot/tests/test_help_commands.py
new file mode 100644
index 0000000..5ba0dd7
--- /dev/null
+++ b/NightCityBot/tests/test_help_commands.py
@@ -0,0 +1,18 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Run the help commands."""
+    logs: List[str] = []
+    admin = suite.bot.get_cog('Admin')
+    ctx.send = AsyncMock()
+    await admin.helpme(ctx)
+    await admin.helpfixer(ctx)
+    if ctx.send.await_count >= 2:
+        logs.append("✅ helpme and helpfixer executed")
+    else:
+        logs.append("❌ Help commands failed")
+    return logs
diff --git a/NightCityBot/tests/test_ignore_unbelievaboat.py b/NightCityBot/tests/test_ignore_unbelievaboat.py
new file mode 100644
index 0000000..54c6bcd
--- /dev/null
+++ b/NightCityBot/tests/test_ignore_unbelievaboat.py
@@ -0,0 +1,20 @@
+from typing import List
+from discord.ext import commands
+from unittest.mock import AsyncMock
+import config
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure UnbelievaBoat economy commands are ignored."""
+    logs: List[str] = []
+    admin = suite.bot.get_cog('Admin')
+    ctx.send = AsyncMock()
+    ctx.message.content = "!bal"
+    try:
+        await admin.on_command_error(ctx, commands.CommandNotFound('bal'))
+        if ctx.send.await_count == 0:
+            logs.append("✅ UnbelievaBoat command ignored")
+        else:
+            logs.append("❌ UnbelievaBoat command produced a message")
+    except Exception as e:
+        logs.append(f"❌ Exception: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_loa_commands.py b/NightCityBot/tests/test_loa_commands.py
new file mode 100644
index 0000000..b4ae269
--- /dev/null
+++ b/NightCityBot/tests/test_loa_commands.py
@@ -0,0 +1,32 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure LOA start and end commands execute."""
+    control = suite.bot.get_cog('SystemControl')
+    if control:
+        await control.set_status('loa', True)
+    logs = []
+    loa = suite.bot.get_cog('LOA')
+    if not loa:
+        logs.append("❌ LOA cog not loaded")
+        return logs
+    original_author = ctx.author
+    mock_author = MagicMock(spec=discord.Member)
+    mock_author.id = original_author.id
+    mock_author.roles = []
+    mock_author.add_roles = AsyncMock()
+    mock_author.remove_roles = AsyncMock()
+    ctx.author = mock_author
+    loa_role = discord.Object(id=config.LOA_ROLE_ID)
+    with patch('discord.Guild.get_role', return_value=loa_role):
+        await loa.start_loa(ctx)
+        mock_author.roles.append(loa_role)
+        await loa.end_loa(ctx)
+    suite.assert_send(logs, mock_author.add_roles, "add_roles")
+    suite.assert_send(logs, mock_author.remove_roles, "remove_roles")
+    ctx.author = original_author
+    return logs
diff --git a/NightCityBot/tests/test_loa_fixer_other.py b/NightCityBot/tests/test_loa_fixer_other.py
new file mode 100644
index 0000000..c09a74e
--- /dev/null
+++ b/NightCityBot/tests/test_loa_fixer_other.py
@@ -0,0 +1,37 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+
+async def run(suite, ctx) -> List[str]:
+    """Fixer starts and ends LOA for another user."""
+    logs: List[str] = []
+    loa = suite.bot.get_cog('LOA')
+    if not loa:
+        logs.append("❌ LOA cog not loaded")
+        return logs
+    original_author = ctx.author
+    mock_author = MagicMock(spec=discord.Member)
+    mock_author.id = original_author.id
+    mock_author.roles = []
+    ctx.author = mock_author
+    fixer = MagicMock()
+    fixer.name = config.FIXER_ROLE_NAME
+    ctx.author.roles.append(fixer)
+    target = MagicMock(spec=discord.Member)
+    target.roles = []
+    target.add_roles = AsyncMock()
+    target.remove_roles = AsyncMock()
+    loa_role = discord.Object(id=config.LOA_ROLE_ID)
+    loa_role.id = config.LOA_ROLE_ID
+    # Patch the get_role method at the class level to avoid issues with
+    # Discord's read-only attributes when ctx.guild is a real Guild instance.
+    with patch('NightCityBot.cogs.loa.get_loa_role', return_value=loa_role):
+        await loa.start_loa.callback(loa, ctx, target)
+        target.roles.append(loa_role)
+        await loa.end_loa.callback(loa, ctx, target)
+    suite.assert_send(logs, target.add_roles, "add_roles")
+    suite.assert_send(logs, target.remove_roles, "remove_roles")
+    ctx.author.roles.remove(fixer)
+    ctx.author = original_author
+    return logs
diff --git a/NightCityBot/tests/test_loa_id_check.py b/NightCityBot/tests/test_loa_id_check.py
new file mode 100644
index 0000000..de80923
--- /dev/null
+++ b/NightCityBot/tests/test_loa_id_check.py
@@ -0,0 +1,37 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure LOA works when different Role objects share the same ID."""
+    logs: List[str] = []
+    loa = suite.bot.get_cog('LOA')
+    if not loa:
+        logs.append("❌ LOA cog not loaded")
+        return logs
+    original_author = ctx.author
+    mock_author = MagicMock(spec=discord.Member)
+    mock_author.id = original_author.id
+    mock_author.roles = []
+    ctx.author = mock_author
+    fixer = MagicMock()
+    fixer.name = config.FIXER_ROLE_NAME
+    ctx.author.roles.append(fixer)
+    target = MagicMock(spec=discord.Member)
+    target.roles = []
+    target.add_roles = AsyncMock()
+    target.remove_roles = AsyncMock()
+    loa_role1 = discord.Object(id=config.LOA_ROLE_ID)
+    loa_role1.id = config.LOA_ROLE_ID
+    loa_role2 = discord.Object(id=config.LOA_ROLE_ID)
+    loa_role2.id = config.LOA_ROLE_ID
+    with patch('discord.Guild.get_role', side_effect=[loa_role1, loa_role2]):
+        await loa.start_loa.callback(loa, ctx, target)
+        target.roles.append(loa_role1)
+        await loa.end_loa.callback(loa, ctx, target)
+    suite.assert_send(logs, target.add_roles, "add_roles")
+    suite.assert_send(logs, target.remove_roles, "remove_roles")
+    ctx.author.roles.remove(fixer)
+    ctx.author = original_author
+    return logs
diff --git a/NightCityBot/tests/test_message_cleanup.py b/NightCityBot/tests/test_message_cleanup.py
new file mode 100644
index 0000000..297344e
--- /dev/null
+++ b/NightCityBot/tests/test_message_cleanup.py
@@ -0,0 +1,35 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch, PropertyMock
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure !dm and !post delete the invoking message."""
+    logs: List[str] = []
+    dm_cog = suite.bot.get_cog('DMHandler')
+    admin_cog = suite.bot.get_cog('Admin')
+    user = await suite.get_test_user(ctx)
+
+    ctx.message.delete = AsyncMock()
+    ctx.message.attachments = []
+    with patch.object(type(user), "send", new=AsyncMock()), \
+         patch.object(dm_cog, "get_or_create_dm_thread", new=AsyncMock(return_value=MagicMock(spec=discord.Thread))):
+        await dm_cog.dm.callback(dm_cog, ctx, user, message="Hello")
+    if ctx.message.delete.await_count:
+        logs.append("✅ !dm deleted command message")
+    else:
+        logs.append("❌ !dm did not delete command")
+
+    ctx.message.delete.reset_mock()
+    dest = MagicMock(spec=discord.TextChannel)
+    dest.name = "general"
+    dest.send = AsyncMock()
+    parent = MagicMock()
+    parent.threads = []
+    with patch.object(type(ctx.guild), "text_channels", new=PropertyMock(return_value=[dest, parent])):
+        with patch.object(suite.bot, "invoke", new=AsyncMock()):
+            await admin_cog.post(ctx, dest.name, message="Test")
+    if ctx.message.delete.await_count:
+        logs.append("✅ !post deleted command message")
+    else:
+        logs.append("❌ !post did not delete command")
+    return logs
diff --git a/NightCityBot/tests/test_open_shop_command.py b/NightCityBot/tests/test_open_shop_command.py
new file mode 100644
index 0000000..ad50cd0
--- /dev/null
+++ b/NightCityBot/tests/test_open_shop_command.py
@@ -0,0 +1,32 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test shop opening functionality."""
+    logs = []
+    try:
+        correct_channel = ctx.guild.get_channel(config.BUSINESS_ACTIVITY_CHANNEL_ID)
+        logs.append("→ Expected: !open_shop should succeed when run inside the business channel.")
+
+        control = suite.bot.get_cog('SystemControl')
+        if control:
+            await control.set_status('open_shop', True)
+
+        if not correct_channel:
+            logs.append("→ Result: ❌ Business open channel not found")
+            return logs
+
+        original_channel = ctx.channel
+        ctx.channel = correct_channel
+
+        economy = suite.bot.get_cog('Economy')
+        await economy.open_shop(ctx)
+        logs.append("→ Result: ✅ !open_shop executed in correct channel")
+
+        ctx.channel = original_channel
+    except Exception as e:
+        logs.append(f"❌ Exception in test_open_shop_command: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_open_shop_daily_limit.py b/NightCityBot/tests/test_open_shop_daily_limit.py
new file mode 100644
index 0000000..334cd43
--- /dev/null
+++ b/NightCityBot/tests/test_open_shop_daily_limit.py
@@ -0,0 +1,45 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+from datetime import datetime
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure users can't log a business opening twice on the same day."""
+    control = suite.bot.get_cog('SystemControl')
+    if control:
+        await control.set_status('open_shop', True)
+    logs = []
+    economy = suite.bot.get_cog('Economy')
+    original_channel = ctx.channel
+    ctx.channel = ctx.guild.get_channel(config.BUSINESS_ACTIVITY_CHANNEL_ID)
+
+    storage = {}
+
+    async def fake_load(*_, **__):
+        return storage.get("data", {})
+
+    async def fake_save(path, data):
+        storage["data"] = data
+
+    ctx.send = AsyncMock()
+
+    sunday = datetime(2025, 6, 15)
+    with (
+        patch("NightCityBot.cogs.economy.datetime") as mock_dt,
+        patch("NightCityBot.cogs.economy.load_json_file", new=fake_load),
+        patch("NightCityBot.cogs.economy.save_json_file", new=fake_save),
+        patch.object(economy.unbelievaboat, "update_balance", new=AsyncMock()),
+    ):
+        mock_dt.now.return_value = sunday
+        mock_dt.fromisoformat = datetime.fromisoformat
+        await economy.open_shop(ctx)
+        await economy.open_shop(ctx)
+    msg = ctx.send.call_args_list[-1][0][0]
+    if "already logged a business opening today" in msg:
+        logs.append("✅ open_shop rejected when used twice")
+    else:
+        logs.append("❌ open_shop did not enforce daily limit")
+    ctx.channel = original_channel
+    return logs
diff --git a/NightCityBot/tests/test_open_shop_errors.py b/NightCityBot/tests/test_open_shop_errors.py
new file mode 100644
index 0000000..777b686
--- /dev/null
+++ b/NightCityBot/tests/test_open_shop_errors.py
@@ -0,0 +1,45 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+from datetime import datetime
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Verify open_shop fails in wrong channel or on wrong day."""
+    control = suite.bot.get_cog('SystemControl')
+    if control:
+        await control.set_status('open_shop', True)
+    logs = []
+    economy = suite.bot.get_cog('Economy')
+    wrong_channel = ctx.channel
+    monday = datetime(2025, 6, 16)
+    with patch.object(economy.unbelievaboat, "update_balance", new=AsyncMock()), \
+         patch("NightCityBot.cogs.economy.datetime") as mock_dt:
+        mock_dt.now.return_value = monday
+        mock_dt.fromisoformat = datetime.fromisoformat
+        # Wrong channel
+        await economy.open_shop(ctx)
+        logs.append("✅ open_shop rejected outside business channel")
+
+        ctx.channel = ctx.guild.get_channel(config.BUSINESS_ACTIVITY_CHANNEL_ID)
+        original_author = ctx.author
+        mock_author = MagicMock(spec=discord.Member)
+        mock_author.id = original_author.id
+
+        # Simulate no business role
+        mock_author.roles = []
+        ctx.author = mock_author
+        await economy.open_shop(ctx)
+        logs.append("✅ open_shop rejected without business role")
+
+        # Simulate non-Sunday with business role
+        role = MagicMock()
+        role.name = "Business Tier 1"
+        mock_author.roles = [role]
+        await economy.open_shop(ctx)
+        logs.append("✅ open_shop rejected on non-Sunday")
+
+        ctx.channel = wrong_channel
+        ctx.author = original_author
+    return logs
diff --git a/NightCityBot/tests/test_passive_income_logic.py b/NightCityBot/tests/test_passive_income_logic.py
new file mode 100644
index 0000000..ccac535
--- /dev/null
+++ b/NightCityBot/tests/test_passive_income_logic.py
@@ -0,0 +1,18 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test passive income calculations."""
+    logs = []
+    user = await suite.get_test_user(ctx)
+    economy = suite.bot.get_cog('Economy')
+
+    for role in ROLE_COSTS_BUSINESS.keys():
+        for count in range(5):
+            income = economy.calculate_passive_income(role, count)
+            logs.append(f"✅ {role} with {count} opens → ${income}")
+
+    return logs
diff --git a/NightCityBot/tests/test_post_dm_channel.py b/NightCityBot/tests/test_post_dm_channel.py
new file mode 100644
index 0000000..d94189b
--- /dev/null
+++ b/NightCityBot/tests/test_post_dm_channel.py
@@ -0,0 +1,22 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch, PropertyMock
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Run !post from a DM thread."""
+    logs: List[str] = []
+    admin = suite.bot.get_cog('Admin')
+    dest = MagicMock(spec=discord.TextChannel)
+    dest.name = "general"
+    dest.send = AsyncMock()
+    thread_parent = MagicMock()
+    thread_parent.threads = []
+    with patch.object(type(ctx.guild), "text_channels", new=PropertyMock(return_value=[dest, thread_parent])):
+        ctx.message.attachments = []
+        ctx.channel = MagicMock(spec=discord.Thread)
+        ctx.send = AsyncMock()
+        await admin.post(ctx, dest.name, message="Test message")
+    suite.assert_send(logs, dest.send, "dest.send")
+    return logs
diff --git a/NightCityBot/tests/test_post_executes_command.py b/NightCityBot/tests/test_post_executes_command.py
new file mode 100644
index 0000000..8711e88
--- /dev/null
+++ b/NightCityBot/tests/test_post_executes_command.py
@@ -0,0 +1,18 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test posting commands to channels."""
+    logs = []
+    try:
+        rp_channel = ctx.test_rp_channel
+        ctx.message.attachments = []
+        admin_cog = suite.bot.get_cog('Admin')
+        await admin_cog.post(ctx, rp_channel.name, message="!roll 1d4")
+        logs.append("✅ !post executed and command sent in reused RP channel")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_post_executes_command: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_post_roll_as_user.py b/NightCityBot/tests/test_post_roll_as_user.py
new file mode 100644
index 0000000..14deafc
--- /dev/null
+++ b/NightCityBot/tests/test_post_roll_as_user.py
@@ -0,0 +1,21 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch, PropertyMock
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Execute a roll as another user via !post."""
+    logs: List[str] = []
+    admin = suite.bot.get_cog('Admin')
+    thread = MagicMock(spec=discord.Thread)
+    thread.name = "rp-thread"
+    parent = MagicMock()
+    parent.threads = [thread]
+    with patch.object(type(ctx.guild), "text_channels", new=PropertyMock(return_value=[parent])):
+        ctx.message.attachments = []
+        ctx.send = AsyncMock()
+        with patch.object(suite.bot, "invoke", new=AsyncMock()) as mock_invoke:
+            await admin.post(ctx, thread.name, message=f"!roll d20 {ctx.author.id}")
+    suite.assert_called(logs, mock_invoke, "bot.invoke")
+    return logs
diff --git a/NightCityBot/tests/test_post_roll_execution.py b/NightCityBot/tests/test_post_roll_execution.py
new file mode 100644
index 0000000..afed7c1
--- /dev/null
+++ b/NightCityBot/tests/test_post_roll_execution.py
@@ -0,0 +1,17 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test roll execution via post command."""
+    logs = []
+    try:
+        thread = ctx.test_rp_channel
+        admin_cog = suite.bot.get_cog('Admin')
+        await admin_cog.post(ctx, thread.name, message="!roll 1d20+1")
+        logs.append("✅ !post <thread> !roll d20+1 executed in reused RP channel")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_post_roll_execution: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_pytest_loa.py b/NightCityBot/tests/test_pytest_loa.py
new file mode 100644
index 0000000..1cf9698
--- /dev/null
+++ b/NightCityBot/tests/test_pytest_loa.py
@@ -0,0 +1,48 @@
+import asyncio
+from unittest.mock import AsyncMock, MagicMock
+import config
+
+from NightCityBot.cogs.loa import LOA
+from NightCityBot.cogs.test_suite import TestSuite
+from NightCityBot.tests.test_loa_fixer_other import run as run_fixer_other
+from NightCityBot.tests.test_loa_id_check import run as run_id_check
+
+class DummyBot:
+    def __init__(self):
+        self.cogs = {}
+        self.loop = asyncio.new_event_loop()
+    def add_cog(self, cog):
+        self.cogs[cog.__class__.__name__] = cog
+    def get_cog(self, name):
+        return self.cogs.get(name)
+
+class DummyCtx:
+    def __init__(self):
+        self.guild = MagicMock()
+        self.guild.get_member.return_value = MagicMock(id=config.TEST_USER_ID)
+        self.guild.fetch_member = AsyncMock(return_value=MagicMock(id=config.TEST_USER_ID))
+        self.author = MagicMock(roles=[], display_name="Author")
+        self.channel = MagicMock()
+        self.send = AsyncMock()
+        self.message = MagicMock(attachments=[])
+
+def setup_suite():
+    bot = DummyBot()
+    bot.add_cog(LOA(bot))
+    return TestSuite(bot)
+
+
+def run_test(func):
+    suite = setup_suite()
+    ctx = DummyCtx()
+    return asyncio.run(func(suite, ctx))
+
+
+def test_loa_fixer_other():
+    logs = run_test(run_fixer_other)
+    assert all("❌" not in l for l in logs), f"Logs: {logs}"
+
+
+def test_loa_id_check():
+    logs = run_test(run_id_check)
+    assert all("❌" not in l for l in logs), f"Logs: {logs}"
diff --git a/NightCityBot/tests/test_rent_logging_sends.py b/NightCityBot/tests/test_rent_logging_sends.py
new file mode 100644
index 0000000..a2bcbf2
--- /dev/null
+++ b/NightCityBot/tests/test_rent_logging_sends.py
@@ -0,0 +1,26 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test rent logging functionality."""
+    logs = []
+    try:
+        user = await suite.get_test_user(ctx)
+        rent_log_channel = ctx.guild.get_channel(config.RENT_LOG_CHANNEL_ID)
+        eviction_channel = ctx.guild.get_channel(config.EVICTION_CHANNEL_ID)
+
+        logs.append("→ Expected: collect_rent should post messages to rent and eviction log channels.")
+
+        if not rent_log_channel or not eviction_channel:
+            logs.append("→ Result: ❌ Rent or eviction channels not found.")
+            return logs
+
+        economy = suite.bot.get_cog('Economy')
+        await economy.collect_rent(ctx, target_user=user)
+        logs.append("→ Result: ✅ Rent logic executed and logging channels present.")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_rent_logging_sends: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_roll_as_user.py b/NightCityBot/tests/test_roll_as_user.py
new file mode 100644
index 0000000..d2ed7f1
--- /dev/null
+++ b/NightCityBot/tests/test_roll_as_user.py
@@ -0,0 +1,28 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Roll on behalf of another user."""
+    logs: List[str] = []
+    roll = suite.bot.get_cog('RollSystem')
+    user = await suite.get_test_user(ctx)
+    with patch.object(type(ctx.guild), "get_member", return_value=user):
+        ctx.channel = MagicMock()
+        ctx.message = MagicMock()
+        ctx.message.delete = AsyncMock()
+        with patch.object(roll, "loggable_roll", new=AsyncMock()) as mock_log:
+            await roll.roll.callback(roll, ctx, dice=f"2d6 <@{user.id}>")
+        if mock_log.await_args.args[0] == user:
+            logs.append("✅ roll executed for mentioned user")
+        else:
+            logs.append("❌ roll did not use mentioned user")
+        with patch.object(roll, "loggable_roll", new=AsyncMock()) as mock_log2:
+            await roll.roll.callback(roll, ctx, dice=f"2d6 {user.id}")
+        if mock_log2.await_args.args[0] == user:
+            logs.append("✅ roll executed for ID user")
+        else:
+            logs.append("❌ roll did not use ID user")
+    return logs
diff --git a/NightCityBot/tests/test_roll_direct_dm.py b/NightCityBot/tests/test_roll_direct_dm.py
new file mode 100644
index 0000000..16601db
--- /dev/null
+++ b/NightCityBot/tests/test_roll_direct_dm.py
@@ -0,0 +1,21 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test roll command in direct DMs."""
+    logs = []
+    try:
+        user = await suite.get_test_user(ctx)
+        dm_channel = MagicMock()
+        with patch.object(type(user), "create_dm", new=AsyncMock(return_value=dm_channel)):
+            roll_system = suite.bot.get_cog("RollSystem")
+            with patch.object(roll_system, "loggable_roll", new=AsyncMock()) as mock_roll:
+                await roll_system.loggable_roll(user, dm_channel, "1d6")
+                suite.assert_called(logs, mock_roll, "loggable_roll")
+
+    except Exception as e:
+        logs.append(f"❌ Exception in test_roll_direct_dm: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_rolls.py b/NightCityBot/tests/test_rolls.py
new file mode 100644
index 0000000..a93c094
--- /dev/null
+++ b/NightCityBot/tests/test_rolls.py
@@ -0,0 +1,23 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test roll command functionality."""
+    logs = []
+    try:
+        logs.append("→ Expected: Valid roll should return a total, invalid roll should return a format error.")
+
+        roll_system = suite.bot.get_cog('RollSystem')
+        # Valid roll
+        await roll_system.loggable_roll(ctx.author, ctx.channel, "1d20+2")
+        logs.append("→ Result (Valid): ✅ Roll succeeded and result sent.")
+
+        # Invalid roll
+        await roll_system.loggable_roll(ctx.author, ctx.channel, "notadice")
+        logs.append("→ Result (Invalid): ✅ Error message shown for invalid format.")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_rolls: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_simulate_commands.py b/NightCityBot/tests/test_simulate_commands.py
new file mode 100644
index 0000000..c5da0eb
--- /dev/null
+++ b/NightCityBot/tests/test_simulate_commands.py
@@ -0,0 +1,24 @@
+from typing import List
+from unittest.mock import AsyncMock, patch
+import discord
+
+async def run(suite, ctx) -> List[str]:
+    """Run rent and cyberware simulations and ensure audit logging."""
+    logs: List[str] = []
+    economy = suite.bot.get_cog('Economy')
+    cyber = suite.bot.get_cog('CyberwareManager')
+    admin = suite.bot.get_cog('Admin')
+    ctx.send = AsyncMock()
+    with (
+        patch.object(economy.unbelievaboat, "get_balance", new=AsyncMock(return_value={"cash": 1000, "bank": 0})),
+        patch.object(economy.unbelievaboat, "update_balance", new=AsyncMock(return_value=True)),
+        patch.object(cyber.unbelievaboat, "get_balance", new=AsyncMock(return_value={"cash": 1000, "bank": 0})),
+        patch.object(cyber.unbelievaboat, "update_balance", new=AsyncMock(return_value=True)),
+        patch.object(admin, "log_audit", new=AsyncMock()) as mock_audit,
+        patch("NightCityBot.cogs.cyberware.save_json_file", new=AsyncMock()),
+    ):
+        await economy.simulate_rent(ctx, target_user=ctx.author)
+        await cyber.simulate_cyberware(ctx, member=str(ctx.author.id))
+        await cyber.simulate_cyberware(ctx, member=str(ctx.author.id), weeks=3)
+        suite.assert_called(logs, mock_audit, "log_audit")
+    return logs
diff --git a/NightCityBot/tests/test_start_end_rp.py b/NightCityBot/tests/test_start_end_rp.py
new file mode 100644
index 0000000..6d74d53
--- /dev/null
+++ b/NightCityBot/tests/test_start_end_rp.py
@@ -0,0 +1,20 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Create and end an RP session to confirm logging works."""
+    logs = []
+    rp_manager = suite.bot.get_cog('RPManager')
+    channel = await rp_manager.start_rp(ctx, f"<@{config.TEST_USER_ID}>")
+    suite.debug(logs, f"start_rp created: {getattr(channel, 'name', None)}")
+    if channel:
+        logs.append("✅ start_rp returned a channel")
+        await rp_manager.end_rp(ctx)
+        suite.debug(logs, "end_rp called")
+        logs.append("✅ end_rp executed without error")
+    else:
+        logs.append("❌ start_rp failed to create a channel")
+    return logs
diff --git a/NightCityBot/tests/test_start_rp_multi.py b/NightCityBot/tests/test_start_rp_multi.py
new file mode 100644
index 0000000..f002bd7
--- /dev/null
+++ b/NightCityBot/tests/test_start_rp_multi.py
@@ -0,0 +1,25 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Start RP with two users and roll inside."""
+    logs: List[str] = []
+    rp = suite.bot.get_cog('RPManager')
+    user = await suite.get_test_user(ctx)
+    channel = MagicMock(spec=discord.TextChannel)
+    channel.name = "text-rp-test"
+    rp.create_group_rp_channel = AsyncMock(return_value=channel)
+    result = await rp.start_rp(ctx, f"<@{user.id}>", str(ctx.author.id))
+    suite.debug(logs, f"start_rp_multi created: {getattr(result, 'name', None)}")
+    if result:
+        logs.append("✅ start_rp handled users")
+    await suite.bot.get_cog('RollSystem').loggable_roll(ctx.author, channel, "1d6")
+    rp.end_rp_session = AsyncMock()
+    ctx.channel = channel
+    await rp.end_rp(ctx)
+    suite.debug(logs, "end_rp called in multi")
+    suite.assert_called(logs, rp.end_rp_session, "end_rp_session")
+    return logs
diff --git a/NightCityBot/tests/test_test_bot_dm.py b/NightCityBot/tests/test_test_bot_dm.py
new file mode 100644
index 0000000..62f110d
--- /dev/null
+++ b/NightCityBot/tests/test_test_bot_dm.py
@@ -0,0 +1,22 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+from NightCityBot import tests
+
+async def run(suite, ctx) -> List[str]:
+    """Ensure test_bot sends results via DM when -silent is used."""
+    logs: List[str] = []
+    test_cog = suite.bot.get_cog('TestSuite')
+    dm_channel = MagicMock()
+    dm_channel.send = AsyncMock()
+    ctx.send = AsyncMock()
+    ctx.message.attachments = []
+    with patch.object(type(ctx.author), "create_dm", new=AsyncMock(return_value=dm_channel)):
+        # Limit to a simple test
+        test_cog.tests = {'test_help_commands': tests.TEST_FUNCTIONS['test_help_commands']}
+        await test_cog.test_bot(ctx, 'test_help_commands', '-silent')
+        if any('embed' in kwargs for _, kwargs in dm_channel.send.call_args_list):
+            logs.append('✅ test_bot DM summary sent')
+        else:
+            logs.append('❌ test_bot did not send DM summary')
+    return logs
diff --git a/NightCityBot/tests/test_trauma_payment.py b/NightCityBot/tests/test_trauma_payment.py
new file mode 100644
index 0000000..396ea1e
--- /dev/null
+++ b/NightCityBot/tests/test_trauma_payment.py
@@ -0,0 +1,19 @@
+from typing import List
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Test Trauma Team subscription processing."""
+    logs = []
+    try:
+        user = await suite.get_test_user(ctx)
+        logs.append("→ Expected: collect_trauma should find thread and log subscription payment.")
+
+        economy = suite.bot.get_cog('Economy')
+        await economy.collect_trauma(ctx, user)
+        logs.append("→ Result: ✅ Trauma Team logic executed on live user (check #tt-plans-payment).")
+    except Exception as e:
+        logs.append(f"❌ Exception in test_trauma_payment: {e}")
+    return logs
diff --git a/NightCityBot/tests/test_unknown_command.py b/NightCityBot/tests/test_unknown_command.py
new file mode 100644
index 0000000..ff32e31
--- /dev/null
+++ b/NightCityBot/tests/test_unknown_command.py
@@ -0,0 +1,19 @@
+from typing import List
+from discord.ext import commands
+import discord
+from unittest.mock import AsyncMock, MagicMock, patch
+import config
+from NightCityBot.utils.constants import ROLE_COSTS_BUSINESS, ROLE_COSTS_HOUSING
+
+async def run(suite, ctx) -> List[str]:
+    """Send an unknown ! command and ensure it's ignored."""
+    logs = []
+    admin = suite.bot.get_cog('Admin')
+    try:
+        msg = ctx.message
+        msg.content = "!notacommand"
+        await admin.on_command_error(ctx, commands.CommandNotFound("notacommand"))
+        logs.append("✅ Unknown command handled without audit log")
+    except Exception as e:
+        logs.append(f"❌ Exception handling unknown command: {e}")
+    return logs
diff --git a/NightCityBot/utils/constants.py b/NightCityBot/utils/constants.py
index 50c8656..9afcb95 100644
--- a/NightCityBot/utils/constants.py
+++ b/NightCityBot/utils/constants.py
@@ -25,3 +25,108 @@ BASELINE_LIVING_COST = 500
 # Passive income scales
 TIER_0_INCOME_SCALE = {1: 150, 2: 250, 3: 350, 4: 500}
 OPEN_PERCENT = {0: 0, 1: 0.25, 2: 0.4, 3: 0.6, 4: 0.8}
+ATTEND_REWARD = 250
+
+# Commands from UnbelievaBoat to ignore in unknown command handler
+UNBELIEVABOAT_COMMANDS = {
+    "add-cash-role", "add-fail-reply", "add-failed-reply", "add-fine-reply",
+    "add-money", "add-money-role", "add-payout-reply", "add-reply", "agree",
+    "agree-channel", "agree-role", "aki", "akinator", "amped-fm", "amped.fm", "animal",
+    "animal-race", "animal-scale", "animals", "animals-scale", "ass",
+    "assignable-role", "assignable-roles", "auto-mod-ignore", "auto-mod-ignored",
+    "auto-mod-invites", "auto-mod-mentions", "auto-mod-silenced", "auto-mod-silent",
+    "auto-moderation-invites", "auto-moderation-mentions", "auto-play", "auto-role",
+    "auto-roles", "b", "b-boost", "bal", "balance", "ban", "banne", "barn", "bass",
+    "bass-boost", "bass-boosted", "bean", "bet-limit", "bet-limits", "bj", "bj-decks",
+    "blackjack", "blackjack-decks", "boob", "boobies", "boobs", "booty", "bot-commander",
+    "bot-commander-role", "butt", "butts", "buy", "buy-item", "c-f", "c-mute", "c-un-mute",
+    "case", "case-edit", "case-reason", "cat", "cat-pic", "cats", "cf-win-chance",
+    "cf-win-rate", "change-currency", "channel", "channel-agree", "channel-info",
+    "channel-lock-down", "channel-override", "channel-overwrite", "channel-permit",
+    "chat-amount", "chat-channel", "chat-channels", "chat-cooldown", "chat-money",
+    "chat-money-amount", "chat-money-channel", "chat-money-channels", "chat-money-cooldown",
+    "chat-mute", "chat-un-mute", "check-upvoted", "chicken-fight", "choose",
+    "clean-lb", "clean-leaderboard", "clear", "clear-queue", "cmc", "cock-fight",
+    "cock-fight-win-chance", "cock-fight-win-rate", "collect", "collect-income",
+    "collect-role-income", "command-cooldown", "command-status", "commander-role",
+    "commands", "config-currency", "cooldown", "cooldown-set", "counting",
+    "counting-channel", "create-item", "crime", "currency-set", "currency-symbol",
+    "custom-replies", "dad-joke", "daddy-joke", "dashboard", "dc", "dec-cash-role",
+    "dec-money", "decrease-cash-role", "default-replies", "default-reply", "delete",
+    "delete-case", "delete-item", "delete-log", "delete-reminder", "delete-replies",
+    "delete-reply", "delete-warning", "deleted-log", "deleted-message-log", "dep",
+    "deposit", "dice", "dick", "dictate", "disable", "disconnect", "discord-fm",
+    "discord.fm", "docs", "dog", "dog-pic", "dogging", "doggo", "doggy", "dogs",
+    "donate", "donate-money", "donation-verify", "economy-audit-log", "economy-reset",
+    "economy-stats", "edit-case", "edit-item", "edit-log", "edit-reason", "edited-log",
+    "edited-message-log", "enable", "escort", "factory-reset", "fail-rate",
+    "fail-rate-set", "fail-reply-add", "feedback", "fight-chicken", "fight-cock",
+    "fine-amount", "fine-rate-set", "fine-reply-add", "fine-set", "fine-set-amount",
+    "fine-type", "fine-type-set", "force-ban", "forget", "forget-reminder",
+    "game-cooldown", "game-cooldown-set", "give", "give-away", "give-item",
+    "give-money", "goodbye-channel", "goodbye-message", "hack-ban", "hard-kick",
+    "help", "history", "i-am", "i-am-not", "ignore-auto-mod", "inc-cash-role",
+    "inc-money", "increase-cash-role", "inv", "inventory", "invite",
+    "invite-moderation", "invite-protection", "invite-whitelist", "invites",
+    "invites-whitelist", "item-buy", "item-create", "item-edit", "item-give",
+    "item-info", "item-options", "item-update", "item-use", "join", "join-channel",
+    "join-message", "join-money", "join-race", "join-role", "joke", "k", "kick",
+    "kitten", "kitty", "lb", "lb-clean", "leader-board-clean", "leaderboard",
+    "leave", "leave-channel", "leave-message", "leave-role", "left-channel",
+    "list-assignable-roles", "list-auto-roles", "list-custom-replies", "list-reminders",
+    "list-replies", "list-self-roles", "lock-down", "lock-down-channel",
+    "log-channel", "loop", "loop-queue", "m", "mass-role", "max-bal", "max-balance",
+    "maximum-balance", "member", "member-agree", "member-info", "mention-moderation",
+    "mention-spam-protection", "mentions", "message-delete-log", "message-deleted-log",
+    "message-edit-log", "message-edited-log", "message-log-ignore", "message-log-ignored",
+    "mod-channel", "mod-commands", "mod-log", "mod-log-channel", "mod-role",
+    "moderation-log", "moderator-role", "module-status", "money", "money-add",
+    "money-add-role", "money-audit-log", "money-give", "money-remove", "money-reset",
+    "money-rm-role", "mute", "mute-role", "muted", "muted-role", "never-ever",
+    "never-have-i", "never-have-i-ever", "new-item", "next-track", "nhie", "now-playing",
+    "np", "override", "override-channel", "overwrite-channel", "patreon", "pause",
+    "pay", "payout-set", "paypal", "penis", "perm", "permission", "permissions",
+    "permit", "perms", "pick", "play", "play-list", "playlist", "playlists", "prefix",
+    "premium", "profile", "provision", "provisions", "prune", "punishment",
+    "punishments", "purge", "pussy", "qoute", "queue", "quote", "quote-message",
+    "r34", "radio", "radio-station", "random", "random-react", "random-reaction",
+    "random-user", "random-user-reaction", "reason", "reason-edit", "reason-set",
+    "reddit", "remind", "remind-me", "reminder-delete", "reminder-forget",
+    "reminder-list", "reminders", "remove-ban", "remove-case", "remove-cash-role",
+    "remove-item", "remove-money", "remove-money-role", "remove-punishment",
+    "remove-replies", "remove-reply", "remove-warning", "repeat", "repeat-queue",
+    "reply-add", "request", "requests", "reset-balance", "reset-economy",
+    "reset-money", "resume", "rm-ban", "rm-case", "rm-cash-role", "rm-item",
+    "rm-money", "rm-money-role", "rm-punish", "rm-punishment", "rm-replies",
+    "rm-reply", "rob", "role", "role-add-money", "role-agree", "role-id",
+    "role-income", "role-info", "role-me", "roll", "roll-dice", "roulete",
+    "roulette", "roulette-info", "roullete", "roullette", "rr", "rtfm", "rule-34",
+    "rus-roulette", "russian-roulete", "russian-roulette", "russian-roullete",
+    "russian-roullette", "s-b", "s-m", "say", "scale-animal", "scale-animals",
+    "search", "seek", "self-role", "self-roles", "sell", "sell-item", "server",
+    "server-feedback", "server-info", "server-stats", "server-suggest",
+    "set-bet", "set-bet-limit", "set-bj-decks", "set-blackjack-decks", "set-cooldown",
+    "set-currency", "set-currency-symbol", "set-fail-rate", "set-fine",
+    "set-fine-amount", "set-fine-rate", "set-fine-type", "set-game-cooldown",
+    "set-join-balance", "set-join-money", "set-max-balance", "set-payout",
+    "set-payout-amount", "set-prefix", "set-reason", "set-reminder",
+    "set-start-balance", "set-start-money", "set-starting-balance", "set-volume",
+    "shop", "show-reminders", "shuffle", "shuffle-queue", "silent-auto-mod",
+    "skip", "skip-song", "slot", "slot-emote", "slot-machine", "slot-machine-emote",
+    "slot-machine-symbol", "slot-machine-symbols", "slot-symbol", "slots",
+    "slow-mode", "slut", "soft-ban", "start-balance", "start-money",
+    "starting-balance", "starting-money", "station", "stations", "stop", "store",
+    "stream", "sub-reddit", "suggest", "suggestion", "suggestion-channel",
+    "suggestions", "suggestions-channel", "support-server", "t-b", "t-mute",
+    "t-un-mute", "take-item", "temp-ban", "temporary-ban", "test", "text-mute",
+    "text-un-mute", "tits", "titties", "tod", "top", "trade-item", "truth-dare",
+    "truth-or-dare", "un-ban", "un-mute", "un-pause", "update-item", "upvote",
+    "upvoted", "use", "use-item", "user", "user-info", "user-join", "user-leave",
+    "user-left", "user-left-channel", "v-d", "v-k", "verify-donation",
+    "verify-pay-pal", "view-case", "voice-disconnect", "voice-kick", "volume",
+    "volume-level", "vote", "vote-skip", "w", "warn", "warnings", "welcome-channel",
+    "welcome-message", "whitelisted-invite", "whitelisted-invites", "who-is",
+    "whore", "widthdraw", "widthdrawl", "with", "withdraw", "withdrawal",
+    "withdrawl", "work",
+}
+
diff --git a/NightCityBot/utils/helpers.py b/NightCityBot/utils/helpers.py
index 0816138..d311750 100644
--- a/NightCityBot/utils/helpers.py
+++ b/NightCityBot/utils/helpers.py
@@ -17,22 +17,27 @@ def build_channel_name(usernames, max_length=100):
 
     return re.sub(r"[^a-z0-9\-]", "", simple_name.lower())
 
-async def load_json_file(file_path: Path, default=None):
-    """Safely load a JSON file with fallback to default value."""
+async def load_json_file(file_path: Path | str, default=None):
+    """Safely load a JSON file with fallback to default value.
+
+    `file_path` can be either a :class:`pathlib.Path` or a string path.
+    """
+    path = Path(file_path)
     try:
-        if file_path.exists():
-            async with aiofiles.open(file_path, 'r') as f:
+        if path.exists():
+            async with aiofiles.open(path, 'r') as f:
                 return json.loads(await f.read())
     except Exception as e:
-        print(f"Error loading {file_path.name}: {e}")
+        print(f"Error loading {path.name}: {e}")
     return default if default is not None else {}
 
-async def save_json_file(file_path: Path, data):
+async def save_json_file(file_path: Path | str, data):
     """Safely save data to a JSON file."""
+    path = Path(file_path)
     try:
-        async with aiofiles.open(file_path, 'w') as f:
+        async with aiofiles.open(path, 'w') as f:
             await f.write(json.dumps(data, indent=2))
         return True
     except Exception as e:
-        print(f"Error saving {file_path.name}: {e}")
+        print(f"Error saving {path.name}: {e}")
         return False
diff --git a/NightCityBot/utils/permissions.py b/NightCityBot/utils/permissions.py
index 13326cf..7c358fd 100644
--- a/NightCityBot/utils/permissions.py
+++ b/NightCityBot/utils/permissions.py
@@ -24,3 +24,24 @@ def is_fixer():
         return discord.utils.get(member.roles, name=config.FIXER_ROLE_NAME) is not None
 
     return commands.check(predicate)
+
+def is_ripperdoc():
+    """Check that the command author has the Ripperdoc role."""
+
+    async def predicate(ctx):
+        guild = ctx.bot.get_guild(config.GUILD_ID)
+        if not guild:
+            return False
+
+        member = ctx.author
+        if not isinstance(member, discord.Member):
+            member = guild.get_member(ctx.author.id)
+            if not member:
+                try:
+                    member = await guild.fetch_member(ctx.author.id)
+                except discord.NotFound:
+                    return False
+
+        return any(r.id == config.RIPPERDOC_ROLE_ID for r in getattr(member, "roles", []))
+
+    return commands.check(predicate)
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..085cf09
--- /dev/null
+++ b/README.md
@@ -0,0 +1,164 @@
+# NightCityBot
+
+NightCityBot is a Discord bot built with `discord.py` that provides roleplay utilities, economy management and automated moderation tools for a Cyberpunk themed server.  The bot is organised using *cogs* – modular components that group related commands and background tasks.
+
+This document gives an overview of the major modules and how they work.
+
+## Requirements
+
+* Python 3.11+
+* The packages listed in `requirements.txt`
+* A Discord bot token and configuration values in `config.py`
+
+Install dependencies with:
+
+```bash
+pip install -r requirements.txt
+```
+
+## Running the bot
+
+Execute the entry point script:
+
+```bash
+python -m NightCityBot.bot
+```
+
+A small Flask server is also started to keep the bot alive on certain hosting platforms.
+
+## Cogs
+
+### DMHandler
+*File: `NightCityBot/cogs/dm_handling.py`*
+
+Handles anonymous DMs from Fixers to players and maintains a logging thread for each user in the channel defined by `DM_INBOX_CHANNEL_ID`.
+
+Key features:
+
+* `!dm @user <message>` – send an anonymous DM and log the conversation in a private thread.
+* Automatic relay of commands such as `!roll` or `!start_rp` when used from a DM logging thread.
+* Creates/loads the mapping of users to logging threads using `thread_map.json`.
+
+### Economy
+*File: `NightCityBot/cogs/economy.py`*
+
+Manages the in‑game economy and rent collection. It integrates with the [UnbelievaBoat](https://unbelievaboat.com/) economy API.
+
+Main commands:
+
+* `!open_shop` – record a business opening on Sundays and instantly grant passive income based on the business tier.
+* `!attend` – weekly attendance reward for verified players.
+* `!due` – estimate upcoming rent and baseline fees.
+* `!collect_rent` / `!simulate_rent` – perform (or simulate) monthly rent collection across all members. Handles housing rent, business rent, baseline cost and Trauma Team subscriptions.
+* `!collect_housing`, `!collect_business`, `!collect_trauma` – manual per‑member processing.
+
+The cog stores logs in JSON files such as `business_open_log.json` and `attendance_log.json` and consults `NightCityBot/utils/constants.py` for role costs.
+
+### CyberwareManager
+*File: `NightCityBot/cogs/cyberware.py`*
+
+Implements weekly check‑up reminders and medication costs for players with cyberware. A background task runs every Saturday:
+
+1. Gives the `CYBER_CHECKUP_ROLE_ID` role each week.
+2. If the role is kept the following week, deducts a cost based on the cyberware level (medium/high/extreme).
+
+Commands:
+
+* `!simulate_cyberware` – simulate the weekly process or calculate the cost for a particular user/week.
+* `!checkup @user` – ripperdoc command to remove the check‑up role once an in‑character examination is done.
+* `!weeks_without_checkup @user` – display the current streak.
+
+All data is stored in `cyberware_log.json`.
+
+### RPManager
+*File: `NightCityBot/cogs/rp_manager.py`*
+
+Provides tools for creating private RP text channels and archiving them when complete.
+
+* `!start_rp @users` – creates a locked text channel named using `utils.helpers.build_channel_name`.
+* `!end_rp` – archives the channel contents to a thread in `GROUP_AUDIT_LOG_CHANNEL_ID` and then deletes the channel.
+* Commands typed inside `text-rp-*` channels are intercepted and passed back to the bot for processing (allowing `!roll` and other commands inside RP sessions).
+
+### RollSystem
+*File: `NightCityBot/cogs/roll_system.py`*
+
+Simple dice rolling logic supporting `XdY+Z` syntax. Rolls can be used in any channel or DM.
+
+Highlights:
+
+* Applies a netrunner bonus based on the user's roles.
+* Logs DM rolls back to the user's logging thread for record keeping.
+* Supports rolling on behalf of another user when invoked via `!post` or `!dm`.
+
+### LOA
+*File: `NightCityBot/cogs/loa.py`*
+
+Manages Leave‑of‑Absence status.
+
+* `!start_loa` and `!end_loa` – players can toggle their own LOA, while Fixers can specify another member.
+* When on LOA, baseline costs, housing rent and Trauma Team payments are skipped by other cogs.
+
+### SystemControl
+*File: `NightCityBot/cogs/system_control.py`*
+
+A small cog that allows administrators to enable or disable major subsystems at runtime. States are persisted in `system_status.json`.
+
+Commands:
+
+* `!enable_system <name>` / `!disable_system <name>`
+* `!system_status` – show current on/off flags.
+
+### Admin
+*File: `NightCityBot/cogs/admin.py`*
+
+Offers helper commands for staff and global error handling.
+
+* `!post <channel> <message>` – post a message or run a command in another channel/thread. Frequently used in conjunction with `!roll` or `!start_rp`.
+* `!helpme` and `!helpfixer` – display help embeds for regular users and Fixers respectively.
+* Logs actions to `AUDIT_LOG_CHANNEL_ID` via `log_audit`.
+
+### TestSuite
+*File: `NightCityBot/cogs/test_suite.py`*
+
+Exposes the internal test suite directly through Discord commands.
+
+* `!test_bot [tests]` – run selected self‑tests. Without arguments it runs the entire suite defined in `NightCityBot/tests`.
+* `!test__bot [pattern]` – execute the pytest based tests. Mainly used by the repository maintainers.
+
+## Services
+
+The `services` package contains integrations used by the cogs:
+
+* **UnbelievaBoatAPI** (`services/unbelievaboat.py`) – minimal wrapper around the UnbelievaBoat REST API for fetching and updating user balances.
+* **TraumaTeamService** (`services/trauma_team.py`) – helper for processing Trauma Team subscription payments and posting into the configured forum channel.
+
+## Utilities
+
+Utility helpers reside in `NightCityBot/utils`:
+
+* `helpers.py` – asynchronous JSON helpers and the `build_channel_name` function.
+* `permissions.py` – custom checks such as `is_fixer` and `is_ripperdoc`.
+* `constants.py` – economy related constants and command filters.
+
+## Data files
+
+Several JSON files store runtime data:
+
+* `thread_map.json` – mapping of user IDs to DM log thread IDs.
+* `business_open_log.json` – timestamps of each user's `!open_shop` usage.
+* `attendance_log.json` – records weekly attendance.
+* `cyberware_log.json` – weeks since last check‑up for each user.
+* `system_status.json` – persisted enable/disable flags for subsystems.
+
+These files are loaded on startup via `utils.helpers.load_json_file`.
+
+## Testing
+
+A comprehensive suite of automated tests lives in `NightCityBot/tests`.  They can be executed with:
+
+```bash
+pytest
+```
+
+Alternatively, run `!test_bot` inside Discord to perform many of the same checks without leaving the chat.
+
diff --git a/attendance_log.json b/attendance_log.json
new file mode 100644
index 0000000..4c4b61f
--- /dev/null
+++ b/attendance_log.json
@@ -0,0 +1,5 @@
+{
+  "286338318076084226": [
+    "2025-06-15T00:56:41.346176"
+  ]
+}
\ No newline at end of file
diff --git a/business_open_log.json b/business_open_log.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/business_open_log.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/config.py b/config.py
index d7ee3c4..82f202d 100644
--- a/config.py
+++ b/config.py
@@ -12,6 +12,18 @@ RENT_LOG_CHANNEL_ID = 0
 EVICTION_CHANNEL_ID = 0
 TRAUMA_TEAM_ROLE_ID = 0
 TRAUMA_FORUM_CHANNEL_ID = 0
+VERIFIED_ROLE_ID = 0
 THREAD_MAP_FILE = "thread_map.json"
 OPEN_LOG_FILE = "business_open_log.json"
 LAST_RENT_FILE = "last_rent.json"
+BALANCE_BACKUP_DIR = "balance_backups"
+ATTEND_LOG_FILE = "attendance_log.json"
+CYBERWARE_LOG_FILE = "cyberware_log.json"
+SYSTEM_STATUS_FILE = "system_status.json"
+CYBER_CHECKUP_ROLE_ID = 0
+CYBER_MEDIUM_ROLE_ID = 0
+CYBER_HIGH_ROLE_ID = 0
+CYBER_EXTREME_ROLE_ID = 0
+LOA_ROLE_ID = 0
+RIPPERDOC_ROLE_ID = 0
+TIMEZONE = "UTC"
diff --git a/cyberware_log.json b/cyberware_log.json
new file mode 100644
index 0000000..f6c5e3e
--- /dev/null
+++ b/cyberware_log.json
@@ -0,0 +1,3 @@
+{
+  "<MagicMock name='mock.id' id='4408253072'>": 0
+}
\ No newline at end of file
diff --git a/open_history_June_2025.json b/open_history_June_2025.json
new file mode 100644
index 0000000..9817e0a
--- /dev/null
+++ b/open_history_June_2025.json
@@ -0,0 +1,5 @@
+{
+  "286338318076084226": [
+    "2025-06-15T02:26:56.398039"
+  ]
+}
\ No newline at end of file
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000..3477410
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,6 @@
+discord.py
+aiohttp
+Flask
+pytest
+aiofiles
+
diff --git a/system_status.json b/system_status.json
new file mode 100644
index 0000000..912bd57
--- /dev/null
+++ b/system_status.json
@@ -0,0 +1,10 @@
+{
+  "cyberware": true,
+  "attend": true,
+  "open_shop": true,
+  "loa": true,
+  "housing_rent": true,
+  "business_rent": true,
+  "trauma_team": true,
+  "dm": true
+}
diff --git a/thread_map.json b/thread_map.json
new file mode 100644
index 0000000..1038bf3
--- /dev/null
+++ b/thread_map.json
@@ -0,0 +1,3 @@
+{
+  "286338318076084226": 1380316261417877614
+}
\ No newline at end of file
